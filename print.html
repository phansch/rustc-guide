<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Guide to Rustc Development</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing rustc ">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./about-this-guide.html"><strong>1.</strong> About this guide</a></li><li><a href="./how-to-build-and-run.html"><strong>2.</strong> How to build the compiler and run what you built</a></li><li><a href="./running-tests.html"><strong>3.</strong> Using the compiler testing framework</a></li><li><a href="./walkthrough.html"><strong>4.</strong> Walkthrough: a typical contribution</a></li><li><a href="./high-level-overview.html"><strong>5.</strong> High-level overview of the compiler source</a></li><li><a href="./query.html"><strong>6.</strong> Queries: demand-driven compilation</a></li><li><ul class="section"><li><a href="./incremental-compilation.html"><strong>6.1.</strong> Incremental compilation</a></li></ul></li><li><a href="./the-parser.html"><strong>7.</strong> The parser</a></li><li><a href="./macro-expansion.html"><strong>8.</strong> Macro expansion</a></li><li><a href="./name-resolution.html"><strong>9.</strong> Name resolution</a></li><li><a href="./hir.html"><strong>10.</strong> The HIR (High-level IR)</a></li><li><a href="./ty.html"><strong>11.</strong> The <code>ty</code> module: representing types</a></li><li><a href="./type-inference.html"><strong>12.</strong> Type inference</a></li><li><a href="./trait-resolution.html"><strong>13.</strong> Trait resolution</a></li><li><a href="./type-checking.html"><strong>14.</strong> Type checking</a></li><li><a href="./mir.html"><strong>15.</strong> The MIR (Mid-level IR)</a></li><li><ul class="section"><li><a href="./mir-construction.html"><strong>15.1.</strong> MIR construction</a></li><li><a href="./mir-borrowck.html"><strong>15.2.</strong> MIR borrowck</a></li><li><a href="./mir-optimizations.html"><strong>15.3.</strong> MIR optimizations</a></li></ul></li><li><a href="./trans.html"><strong>16.</strong> Generating LLVM IR</a></li><li><a href="./glossary.html"><strong>17.</strong> Glossary</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Guide to Rustc Development</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#about-this-guide" id="about-this-guide"><h1>About this guide</h1></a>
<p>This guide is meant to help document how rustc – the Rust compiler –
works, as well as to help new contributors get involved in rustc
development. It is not meant to replace code documentation – each
chapter gives only high-level details – the kinds of things that
(ideally) don't change frequently.</p>
<p>The guide itself is of course open-source as well, and the sources can
be found at the <a href="https://github.com/rust-lang-nursery/rustc-guide/">GitHub repository</a>. If you find any mistakes in the
guide, please file an issue about it, or even better, open a PR
with a correction!</p>
<a class="header" href="print.html#how-to-build-the-compiler-and-run-what-you-built" id="how-to-build-the-compiler-and-run-what-you-built"><h1>How to build the compiler and run what you built</h1></a>
<p>The compiler is built using a tool called <code>x.py</code>. You will need to
have Python installed to run it. But before we get to that, if you're going to
be hacking on rustc, you'll want to tweak the configuration of the compiler. The default
configuration is oriented towards running the compiler as a user, not a developer.</p>
<a class="header" href="print.html#create-a-configtoml" id="create-a-configtoml"><h3>Create a config.toml</h3></a>
<p>To start, copy <a href="https://github.com/rust-lang/rust/blob/master/config.toml.example"><code>config.toml.example</code></a> to <code>config.toml</code>:</p>
<pre><code class="language-bash">&gt; cd $RUST_CHECKOUT
&gt; cp config.toml.example config.toml
</code></pre>
<p>Then you will want to open up the file and change the following
settings (and possibly others, such as <code>llvm.ccache</code>):</p>
<pre><code class="language-toml">[llvm]
# Enables LLVM assertions, which will check that the LLVM bitcode generated
# by the compiler is internally consistent. These are particularly helpful
# if you edit `trans`.
assertions = true

[rust]
# This enables some assertions, but more importantly it enables the `debug!` logging
# macros that are essential for debugging rustc.
debug-assertions = true

# This will make your build more parallel; it costs a bit of runtime
# performance perhaps (less inlining) but it's worth it.
codegen-units = 0

# I always enable full debuginfo, though debuginfo-lines is more important.
debuginfo = true

# Gives you line numbers for backtraces.
debuginfo-lines = true

# Using the system allocator (instead of jemalloc) means that tools
# like valgrind and memcache work better.
use-jemalloc = false
</code></pre>
<a class="header" href="print.html#running-xpy-and-building-a-stage1-compiler" id="running-xpy-and-building-a-stage1-compiler"><h3>Running x.py and building a stage1 compiler</h3></a>
<p>One thing to keep in mind is that <code>rustc</code> is a <em>bootstrapping</em> compiler. That
is, since <code>rustc</code> is written in Rust, we need to use an older version of the
compiler to compile the newer version. In particular, the newer version of the
compiler, <code>libstd</code>, and other tooling may use some unstable features
internally. The result is the compiling <code>rustc</code> is done in stages.</p>
<ul>
<li><strong>Stage 0:</strong> the stage0 compiler is the current <em>beta</em> compiler; we
download this binary from the internet.</li>
<li><strong>Stage 1:</strong> the code in your clone is then compiled with the stage
0 compiler to produce the stage 1 compiler.</li>
<li><strong>Stage 2:</strong> the code in your clone is then compiled with the stage
1 compiler <em>again</em> to produce the stage 2 compiler (i.e. it builds
itself).</li>
</ul>
<p>For hacking, often building the stage 1 compiler is enough, but for
final testing and release, the stage 2 compiler is used.</p>
<p>Once you've created a config.toml, you are now ready to run
<code>x.py</code>. There are a lot of options here, but let's start with what is
probably the best &quot;go to&quot; command for building a local rust:</p>
<pre><code>./x.py build -i --stage 1 src/libstd
</code></pre>
<p>What this command will do is the following:</p>
<ul>
<li>Using the beta compiler (also called stage 0), it will build the
standard library and rustc from the <code>src</code> directory. The resulting
compiler is called the &quot;stage 1&quot; compiler.
<ul>
<li>During this build, the <code>-i</code> (or <code>--incremental</code>) switch enables incremental
compilation, so that if you later rebuild after editing things in
<code>src</code>, you can save a bit of time.</li>
</ul>
</li>
<li>Using this stage 1 compiler, it will build the standard library.
(this is what the <code>src/libstd</code>) means.</li>
</ul>
<p>This is just a subset of the full rustc build. The <strong>full</strong> rustc build (what you
get if you just say <code>./x.py build</code>) has quite a few more steps:</p>
<ul>
<li>Build stage1 rustc with stage0 compiler</li>
<li>Build libstd with stage1 compiler (up to here is the same)</li>
<li>Build rustc from <code>src</code> again, this time with the stage1 compiler (this part is new)
<ul>
<li>The resulting compiler here is called the &quot;stage2&quot; compiler</li>
</ul>
</li>
<li>Build libstd with stage2 compiler</li>
<li>Build librustdoc and a bunch of other things</li>
</ul>
<a class="header" href="print.html#creating-a-rustup-toolchain" id="creating-a-rustup-toolchain"><h3>Creating a rustup toolchain</h3></a>
<p>Once you have successfully built rustc, you will have created a bunch
of files in your <code>build</code> directory. In order to actually run the
resulting rustc, we recommend creating rustup toolchains. The first
one will run the stage1 compiler (which we built above). The second
will execute the stage2 compiler (which we did not build, but which
you will likely need to build at some point; for example, if you want
to run the entire test suite).</p>
<pre><code>&gt; rustup toolchain link stage1 build/&lt;host-triple&gt;/stage1
&gt; rustup toolchain link stage2 build/&lt;host-triple&gt;/stage2
</code></pre>
<p>Now you can run the rustc you built with. If you run with <code>-vV</code>, you
should see a version number ending in <code>-dev</code>, indicating a build from
your local environment:</p>
<pre><code>&gt; rustc +stage1 -vV
rustc 1.25.0-dev
binary: rustc
commit-hash: unknown
commit-date: unknown
host: x86_64-unknown-linux-gnu
release: 1.25.0-dev
LLVM version: 4.0
</code></pre>
<a class="header" href="print.html#other-xpy-commands" id="other-xpy-commands"><h3>Other x.py commands</h3></a>
<p>Here are a few other useful x.py commands. We'll cover some of them in detail in other sections:</p>
<ul>
<li>Building things:
<ul>
<li><code>./x.py clean</code> – clean up the build directory (<code>rm -rf build</code> works too, but then you have to rebuild LLVM)</li>
<li><code>./x.py build --stage 1</code> – builds everything using the stage 1 compiler, not just up to libstd</li>
<li><code>./x.py build</code> – builds the stage2 compiler</li>
</ul>
</li>
<li>Running tests (see the section <a href="./running-tests.html">running tests</a> for more details):
<ul>
<li><code>./x.py test --stage 1 src/libstd</code> – runs the <code>#[test]</code> tests from libstd</li>
<li><code>./x.py test --stage 1 src/test/run-pass</code> – runs the <code>run-pass</code> test suite</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#using-the-compiler-testing-framework" id="using-the-compiler-testing-framework"><h1>Using the compiler testing framework</h1></a>
<a class="header" href="print.html#walkthrough-a-typical-contribution" id="walkthrough-a-typical-contribution"><h1>Walkthrough: a typical contribution</h1></a>
<a class="header" href="print.html#high-level-overview-of-the-compiler-source" id="high-level-overview-of-the-compiler-source"><h1>High-level overview of the compiler source</h1></a>
<a class="header" href="print.html#crate-structure" id="crate-structure"><h2>Crate structure</h2></a>
<p>The main Rust repository consists of a <code>src</code> directory, under which
there live many crates. These crates contain the sources for the
standard library and the compiler.  This document, of course, focuses
on the latter.</p>
<p>Rustc consists of a number of crates, including <code>syntax</code>,
<code>rustc</code>, <code>rustc_back</code>, <code>rustc_trans</code>, <code>rustc_driver</code>, and
many more. The source for each crate can be found in a directory
like <code>src/libXXX</code>, where <code>XXX</code> is the crate name.</p>
<p>(N.B. The names and divisions of these crates are not set in
stone and may change over time. For the time being, we tend towards a
finer-grained division to help with compilation time, though as incremental
compilation improves, that may change.)</p>
<p>The dependency structure of these crates is roughly a diamond:</p>
<pre><code>                  rustc_driver
                /      |       \
              /        |         \
            /          |           \
          /            v             \
rustc_trans    rustc_borrowck   ...  rustc_metadata
          \            |            /
            \          |          /
              \        |        /
                \      v      /
                    rustc
                       |
                       v
                    syntax
                    /    \
                  /       \
           syntax_pos  syntax_ext
</code></pre>
<p>The <code>rustc_driver</code> crate, at the top of this lattice, is effectively
the &quot;main&quot; function for the rust compiler. It doesn't have much &quot;real
code&quot;, but instead ties together all of the code defined in the other
crates and defines the overall flow of execution. (As we transition
more and more to the <a href="query.html">query model</a>, however, the
&quot;flow&quot; of compilation is becoming less centrally defined.)</p>
<p>At the other extreme, the <code>rustc</code> crate defines the common and
pervasive data structures that all the rest of the compiler uses
(e.g. how to represent types, traits, and the program itself). It
also contains some amount of the compiler itself, although that is
relatively limited.</p>
<p>Finally, all the crates in the bulge in the middle define the bulk of
the compiler – they all depend on <code>rustc</code>, so that they can make use
of the various types defined there, and they export public routines
that <code>rustc_driver</code> will invoke as needed (more and more, what these
crates export are &quot;query definitions&quot;, but those are covered later
on).</p>
<p>Below <code>rustc</code> lie various crates that make up the parser and error
reporting mechanism. For historical reasons, these crates do not have
the <code>rustc_</code> prefix, but they are really just as much an internal part
of the compiler and not intended to be stable (though they do wind up
getting used by some crates in the wild; a practice we hope to
gradually phase out).</p>
<p>Each crate has a <code>README.md</code> file that describes, at a high-level,
what it contains, and tries to give some kind of explanation (some
better than others).</p>
<a class="header" href="print.html#the-main-stages-of-compilation" id="the-main-stages-of-compilation"><h2>The main stages of compilation</h2></a>
<p>The Rust compiler is in a bit of transition right now. It used to be a
purely &quot;pass-based&quot; compiler, where we ran a number of passes over the
entire program, and each did a particular check of transformation. We
are gradually replacing this pass-based code with an alternative setup
based on on-demand <strong>queries</strong>. In the query-model, we work backwards,
executing a <em>query</em> that expresses our ultimate goal (e.g. &quot;compile
this crate&quot;). This query in turn may make other queries (e.g. &quot;get me
a list of all modules in the crate&quot;). Those queries make other queries
that ultimately bottom out in the base operations, like parsing the
input, running the type-checker, and so forth. This on-demand model
permits us to do exciting things like only do the minimal amount of
work needed to type-check a single function. It also helps with
incremental compilation. (For details on defining queries, check out
<code>src/librustc/ty/maps/README.md</code>.)</p>
<p>Regardless of the general setup, the basic operations that the
compiler must perform are the same. The only thing that changes is
whether these operations are invoked front-to-back, or on demand.  In
order to compile a Rust crate, these are the general steps that we
take:</p>
<ol>
<li><strong>Parsing input</strong>
<ul>
<li>this processes the <code>.rs</code> files and produces the AST (&quot;abstract syntax tree&quot;)</li>
<li>the AST is defined in <code>syntax/ast.rs</code>. It is intended to match the lexical
syntax of the Rust language quite closely.</li>
</ul>
</li>
<li><strong>Name resolution, macro expansion, and configuration</strong>
<ul>
<li>once parsing is complete, we process the AST recursively, resolving paths
and expanding macros. This same process also processes <code>#[cfg]</code> nodes, and hence
may strip things out of the AST as well.</li>
</ul>
</li>
<li><strong>Lowering to HIR</strong>
<ul>
<li>Once name resolution completes, we convert the AST into the HIR,
or &quot;high-level IR&quot;. The HIR is defined in <code>src/librustc/hir/</code>; that module also includes
the lowering code.</li>
<li>The HIR is a lightly desugared variant of the AST. It is more processed than the
AST and more suitable for the analyses that follow. It is <strong>not</strong> required to match
the syntax of the Rust language.</li>
<li>As a simple example, in the <strong>AST</strong>, we preserve the parentheses
that the user wrote, so <code>((1 + 2) + 3)</code> and <code>1 + 2 + 3</code> parse
into distinct trees, even though they are equivalent. In the
HIR, however, parentheses nodes are removed, and those two
expressions are represented in the same way.</li>
</ul>
</li>
<li><strong>Type-checking and subsequent analyses</strong>
<ul>
<li>An important step in processing the HIR is to perform type
checking. This process assigns types to every HIR expression,
for example, and also is responsible for resolving some
&quot;type-dependent&quot; paths, such as field accesses (<code>x.f</code> – we
can't know what field <code>f</code> is being accessed until we know the
type of <code>x</code>) and associated type references (<code>T::Item</code> – we
can't know what type <code>Item</code> is until we know what <code>T</code> is).</li>
<li>Type checking creates &quot;side-tables&quot; (<code>TypeckTables</code>) that include
the types of expressions, the way to resolve methods, and so forth.</li>
<li>After type-checking, we can do other analyses, such as privacy checking.</li>
</ul>
</li>
<li><strong>Lowering to MIR and post-processing</strong>
<ul>
<li>Once type-checking is done, we can lower the HIR into MIR (&quot;middle IR&quot;), which
is a <strong>very</strong> desugared version of Rust, well suited to the borrowck but also
certain high-level optimizations.</li>
</ul>
</li>
<li><strong>Translation to LLVM and LLVM optimizations</strong>
<ul>
<li>From MIR, we can produce LLVM IR.</li>
<li>LLVM then runs its various optimizations, which produces a number of <code>.o</code> files
(one for each &quot;codegen unit&quot;).</li>
</ul>
</li>
<li><strong>Linking</strong>
<ul>
<li>Finally, those <code>.o</code> files are linked together.</li>
</ul>
</li>
</ol>
<a class="header" href="print.html#queries-demand-driven-compilation" id="queries-demand-driven-compilation"><h1>Queries: demand-driven compilation</h1></a>
<p>As described in <a href="high-level-overview.html">the high-level overview of the compiler</a>, the
Rust compiler is current transitioning from a traditional &quot;pass-based&quot;
setup to a &quot;demand-driven&quot; system. <strong>The Compiler Query System is the
key to our new demand-driven organization.</strong> The idea is pretty
simple. You have various queries that compute things about the input
-- for example, there is a query called <code>type_of(def_id)</code> that, given
the def-id of some item, will compute the type of that item and return
it to you.</p>
<p>Query execution is <strong>memoized</strong> – so the first time you invoke a
query, it will go do the computation, but the next time, the result is
returned from a hashtable. Moreover, query execution fits nicely into
<strong>incremental computation</strong>; the idea is roughly that, when you do a
query, the result <strong>may</strong> be returned to you by loading stored data
from disk (but that's a separate topic we won't discuss further here).</p>
<p>The overall vision is that, eventually, the entire compiler
control-flow will be query driven. There will effectively be one
top-level query (&quot;compile&quot;) that will run compilation on a crate; this
will in turn demand information about that crate, starting from the
<em>end</em>.  For example:</p>
<ul>
<li>This &quot;compile&quot; query might demand to get a list of codegen-units
(i.e. modules that need to be compiled by LLVM).</li>
<li>But computing the list of codegen-units would invoke some subquery
that returns the list of all modules defined in the Rust source.</li>
<li>That query in turn would invoke something asking for the HIR.</li>
<li>This keeps going further and further back until we wind up doing the
actual parsing.</li>
</ul>
<p>However, that vision is not fully realized. Still, big chunks of the
compiler (for example, generating MIR) work exactly like this.</p>
<a class="header" href="print.html#invoking-queries" id="invoking-queries"><h3>Invoking queries</h3></a>
<p>To invoke a query is simple. The tcx (&quot;type context&quot;) offers a method
for each defined query. So, for example, to invoke the <code>type_of</code>
query, you would just do this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let ty = tcx.type_of(some_def_id);
#}</code></pre></pre>
<a class="header" href="print.html#cycles-between-queries" id="cycles-between-queries"><h3>Cycles between queries</h3></a>
<p>Currently, cycles during query execution should always result in a
compilation error. Typically, they arise because of illegal programs
that contain cyclic references they shouldn't (though sometimes they
arise because of compiler bugs, in which case we need to factor our
queries in a more fine-grained fashion to avoid them).</p>
<p>However, it is nonetheless often useful to <em>recover</em> from a cycle
(after reporting an error, say) and try to soldier on, so as to give a
better user experience. In order to recover from a cycle, you don't
get to use the nice method-call-style syntax. Instead, you invoke
using the <code>try_get</code> method, which looks roughly like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use ty::maps::queries;
...
match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {
  Ok(result) =&gt; {
    // no cycle occurred! You can use `result`
  }
  Err(err) =&gt; {
    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,
    // meaning essentially an &quot;in-progress&quot;, not-yet-reported error message.
    // See below for more details on what to do here.
  }
}
#}</code></pre></pre>
<p>So, if you get back an <code>Err</code> from <code>try_get</code>, then a cycle <em>did</em> occur. This means that
you must ensure that a compiler error message is reported. You can do that in two ways:</p>
<p>The simplest is to invoke <code>err.emit()</code>. This will emit the cycle error to the user.</p>
<p>However, often cycles happen because of an illegal program, and you
know at that point that an error either already has been reported or
will be reported due to this cycle by some other bit of code. In that
case, you can invoke <code>err.cancel()</code> to not emit any error. It is
traditional to then invoke:</p>
<pre><code>tcx.sess.delay_span_bug(some_span, &quot;some message&quot;)
</code></pre>
<p><code>delay_span_bug()</code> is a helper that says: we expect a compilation
error to have happened or to happen in the future; so, if compilation
ultimately succeeds, make an ICE with the message <code>&quot;some message&quot;</code>. This is basically just a precaution in case you are wrong.</p>
<a class="header" href="print.html#how-the-compiler-executes-a-query" id="how-the-compiler-executes-a-query"><h3>How the compiler executes a query</h3></a>
<p>So you may be wondering what happens when you invoke a query
method. The answer is that, for each query, the compiler maintains a
cache – if your query has already been executed, then, the answer is
simple: we clone the return value out of the cache and return it
(therefore, you should try to ensure that the return types of queries
are cheaply cloneable; insert a <code>Rc</code> if necessary).</p>
<a class="header" href="print.html#providers" id="providers"><h4>Providers</h4></a>
<p>If, however, the query is <em>not</em> in the cache, then the compiler will
try to find a suitable <strong>provider</strong>. A provider is a function that has
been defined and linked into the compiler somewhere that contains the
code to compute the result of the query.</p>
<p><strong>Providers are defined per-crate.</strong> The compiler maintains,
internally, a table of providers for every crate, at least
conceptually. Right now, there are really two sets: the providers for
queries about the <strong>local crate</strong> (that is, the one being compiled)
and providers for queries about <strong>external crates</strong> (that is,
dependencies of the local crate). Note that what determines the crate
that a query is targeting is not the <em>kind</em> of query, but the <em>key</em>.
For example, when you invoke <code>tcx.type_of(def_id)</code>, that could be a
local query or an external query, depending on what crate the <code>def_id</code>
is referring to (see the <code>self::keys::Key</code> trait for more information
on how that works).</p>
<p>Providers always have the same signature:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn provider&lt;'cx, 'tcx&gt;(tcx: TyCtxt&lt;'cx, 'tcx, 'tcx&gt;,
                       key: QUERY_KEY)
                       -&gt; QUERY_RESULT
{
    ...
}
#}</code></pre></pre>
<p>Providers take two arguments: the <code>tcx</code> and the query key. Note also
that they take the <em>global</em> tcx (i.e. they use the <code>'tcx</code> lifetime
twice), rather than taking a tcx with some active inference context.
They return the result of the query.</p>
<a class="header" href="print.html#how-providers-are-setup" id="how-providers-are-setup"><h4>How providers are setup</h4></a>
<p>When the tcx is created, it is given the providers by its creator using
the <code>Providers</code> struct. This struct is generate by the macros here, but it
is basically a big list of function pointers:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Providers {
    type_of: for&lt;'cx, 'tcx&gt; fn(TyCtxt&lt;'cx, 'tcx, 'tcx&gt;, DefId) -&gt; Ty&lt;'tcx&gt;,
    ...
}
#}</code></pre></pre>
<p>At present, we have one copy of the struct for local crates, and one
for external crates, though the plan is that we may eventually have
one per crate.</p>
<p>These <code>Provider</code> structs are ultimately created and populated by
<code>librustc_driver</code>, but it does this by distributing the work
throughout the other <code>rustc_*</code> crates. This is done by invoking
various <code>provide</code> functions. These functions tend to look something
like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        ..*providers
    };
}
#}</code></pre></pre>
<p>That is, they take an <code>&amp;mut Providers</code> and mutate it in place. Usually
we use the formulation above just because it looks nice, but you could
as well do <code>providers.type_of = type_of</code>, which would be equivalent.
(Here, <code>type_of</code> would be a top-level function, defined as we saw
before.) So, if we want to add a provider for some other query,
let's call it <code>fubar</code>, into the crate above, we might modify the <code>provide()</code>
function like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        fubar,
        ..*providers
    };
}

fn fubar&lt;'cx, 'tcx&gt;(tcx: TyCtxt&lt;'cx, 'tcx&gt;, key: DefId) -&gt; Fubar&lt;'tcx&gt; { .. }
#}</code></pre></pre>
<p>N.B. Most of the <code>rustc_*</code> crates only provide <strong>local
providers</strong>. Almost all <strong>extern providers</strong> wind up going through the
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_metadata"><code>rustc_metadata</code> crate</a>, which loads the information from the crate
metadata.  But in some cases there are crates that provide queries for
<em>both</em> local and external crates, in which case they define both a
<code>provide</code> and a <code>provide_extern</code> function that <code>rustc_driver</code> can
invoke.</p>
<a class="header" href="print.html#adding-a-new-kind-of-query" id="adding-a-new-kind-of-query"><h3>Adding a new kind of query</h3></a>
<p>So suppose you want to add a new kind of query, how do you do so?
Well, defining a query takes place in two steps:</p>
<ol>
<li>first, you have to specify the query name and arguments; and then,</li>
<li>you have to supply query providers where needed.</li>
</ol>
<p>To specify the query name and arguments, you simply add an entry to
the big macro invocation in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/ty/maps/mod.rs"><code>src/librustc/ty/maps/mod.rs</code></a>. This will probably have
changed by the time you read this README, but at present it looks
something like:</p>
<pre><code>define_maps! { &lt;'tcx&gt;
    /// Records the type of every item.
    [] fn type_of: TypeOfItem(DefId) -&gt; Ty&lt;'tcx&gt;,

    ...
}
</code></pre>
<p>Each line of the macro defines one query. The name is broken up like this:</p>
<pre><code>[] fn type_of: TypeOfItem(DefId) -&gt; Ty&lt;'tcx&gt;,
^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^
|     |        |          |         |
|     |        |          |         result type of query
|     |        |          query key type
|     |        dep-node constructor
|     name of query
query flags
</code></pre>
<p>Let's go over them one by one:</p>
<ul>
<li><strong>Query flags:</strong> these are largely unused right now, but the intention
is that we'll be able to customize various aspects of how the query is
processed.</li>
<li><strong>Name of query:</strong> the name of the query method
(<code>tcx.type_of(..)</code>). Also used as the name of a struct
(<code>ty::maps::queries::type_of</code>) that will be generated to represent
this query.</li>
<li><strong>Dep-node constructor:</strong> indicates the constructor function that
connects this query to incremental compilation. Typically, this is a
<code>DepNode</code> variant, which can be added by modifying the
<code>define_dep_nodes!</code> macro invocation in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/dep_graph/dep_node.rs"><code>librustc/dep_graph/dep_node.rs</code></a>.
<ul>
<li>However, sometimes we use a custom function, in which case the
name will be in snake case and the function will be defined at the
bottom of the file. This is typically used when the query key is
not a def-id, or just not the type that the dep-node expects.</li>
</ul>
</li>
<li><strong>Query key type:</strong> the type of the argument to this query.
This type must implement the <code>ty::maps::keys::Key</code> trait, which
defines (for example) how to map it to a crate, and so forth.</li>
<li><strong>Result type of query:</strong> the type produced by this query. This type
should (a) not use <code>RefCell</code> or other interior mutability and (b) be
cheaply cloneable. Interning or using <code>Rc</code> or <code>Arc</code> is recommended for
non-trivial data types.
<ul>
<li>The one exception to those rules is the <code>ty::steal::Steal</code> type,
which is used to cheaply modify MIR in place. See the definition
of <code>Steal</code> for more details. New uses of <code>Steal</code> should <strong>not</strong> be
added without alerting <code>@rust-lang/compiler</code>.</li>
</ul>
</li>
</ul>
<p>So, to add a query:</p>
<ul>
<li>Add an entry to <code>define_maps!</code> using the format above.</li>
<li>Possibly add a corresponding entry to the dep-node macro.</li>
<li>Link the provider by modifying the appropriate <code>provide</code> method;
or add a new one if needed and ensure that <code>rustc_driver</code> is invoking it.</li>
</ul>
<a class="header" href="print.html#query-structs-and-descriptions" id="query-structs-and-descriptions"><h4>Query structs and descriptions</h4></a>
<p>For each kind, the <code>define_maps</code> macro will generate a &quot;query struct&quot;
named after the query. This struct is a kind of a place-holder
describing the query. Each such struct implements the
<code>self::config::QueryConfig</code> trait, which has associated types for the
key/value of that particular query. Basically the code generated looks something
like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Dummy struct representing a particular kind of query:
pub struct type_of&lt;'tcx&gt; { phantom: PhantomData&lt;&amp;'tcx ()&gt; }

impl&lt;'tcx&gt; QueryConfig for type_of&lt;'tcx&gt; {
  type Key = DefId;
  type Value = Ty&lt;'tcx&gt;;
}
#}</code></pre></pre>
<p>There is an additional trait that you may wish to implement called
<code>self::config::QueryDescription</code>. This trait is used during cycle
errors to give a &quot;human readable&quot; name for the query, so that we can
summarize what was happening when the cycle occurred. Implementing
this trait is optional if the query key is <code>DefId</code>, but if you <em>don't</em>
implement it, you get a pretty generic error (&quot;processing <code>foo</code>...&quot;).
You can put new impls into the <code>config</code> module. They look something like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl&lt;'tcx&gt; QueryDescription for queries::type_of&lt;'tcx&gt; {
    fn describe(tcx: TyCtxt, key: DefId) -&gt; String {
        format!(&quot;computing the type of `{}`&quot;, tcx.item_path_str(key))
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#incremental-compilation" id="incremental-compilation"><h1>Incremental compilation</h1></a>
<p>The incremental compilation scheme is, in essence, a surprisingly
simple extension to the overall query system. We'll start by describing
a slightly simplified variant of the real thing – the &quot;basic algorithm&quot; – and then describe
some possible improvements.</p>
<a class="header" href="print.html#the-basic-algorithm" id="the-basic-algorithm"><h2>The basic algorithm</h2></a>
<p>The basic algorithm is
called the <strong>red-green</strong> algorithm<sup class="footnote-reference"><a href="print.html#salsa">1</a></sup>. The high-level idea is
that, after each run of the compiler, we will save the results of all
the queries that we do, as well as the <strong>query DAG</strong>. The
<strong>query DAG</strong> is a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> that indexes which queries executed which
other queries. So, for example, there would be an edge from a query Q1
to another query Q2 if computing Q1 required computing Q2 (note that
because queries cannot depend on themselves, this results in a DAG and
not a general graph).</p>
<p>On the next run of the compiler, then, we can sometimes reuse these
query results to avoid re-executing a query. We do this by assigning
every query a <strong>color</strong>:</p>
<ul>
<li>If a query is colored <strong>red</strong>, that means that its result during
this compilation has <strong>changed</strong> from the previous compilation.</li>
<li>If a query is colored <strong>green</strong>, that means that its result is
the <strong>same</strong> as the previous compilation.</li>
</ul>
<p>There are two key insights here:</p>
<ul>
<li>First, if all the inputs to query Q are colored green, then the
query Q <strong>must</strong> result in the same value as last time and hence
need not be re-executed (or else the compiler is not deterministic).</li>
<li>Second, even if some inputs to a query changes, it may be that it
<strong>still</strong> produces the same result as the previous compilation. In
particular, the query may only use part of its input.
<ul>
<li>Therefore, after executing a query, we always check whether it
produced the same result as the previous time. <strong>If it did,</strong> we
can still mark the query as green, and hence avoid re-executing
dependent queries.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#the-try-mark-green-algorithm" id="the-try-mark-green-algorithm"><h3>The try-mark-green algorithm</h3></a>
<p>At the core of incremental compilation is an algorithm called
&quot;try-mark-green&quot;. It has the job of determining the color of a given
query Q (which must not have yet been executed). In cases where Q has
red inputs, determining Q's color may involve re-executing Q so that
we can compare its output, but if all of Q's inputs are green, then we
can conclude that Q must be green without re-executing it or inspecting
its value at all. In the compiler, this allows us to avoid
deserializing the result from disk when we don't need it, and in fact
enables us to sometimes skip <em>serializing</em> the result as well
(see the refinements section below).</p>
<p>Try-mark-green works as follows:</p>
<ul>
<li>First check if the query Q was executed during the previous compilation.
<ul>
<li>If not, we can just re-execute the query as normal, and assign it the
color of red.</li>
</ul>
</li>
<li>If yes, then load the 'dependent queries' of Q.</li>
<li>If there is a saved result, then we load the <code>reads(Q)</code> vector from the
query DAG. The &quot;reads&quot; is the set of queries that Q executed during
its execution.
<ul>
<li>For each query R in <code>reads(Q)</code>, we recursively demand the color
of R using try-mark-green.
<ul>
<li>Note: it is important that we visit each node in <code>reads(Q)</code> in same order
as they occurred in the original compilation. See <a href="print.html#dag">the section on the query DAG below</a>.</li>
<li>If <strong>any</strong> of the nodes in <code>reads(Q)</code> wind up colored <strong>red</strong>, then Q is dirty.
<ul>
<li>We re-execute Q and compare the hash of its result to the hash of the result
from the previous compilation.</li>
<li>If the hash has not changed, we can mark Q as <strong>green</strong> and return.</li>
</ul>
</li>
<li>Otherwise, <strong>all</strong> of the nodes in <code>reads(Q)</code> must be <strong>green</strong>. In that case,
we can color Q as <strong>green</strong> and return.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="dag"></p>
<a class="header" href="print.html#the-query-dag" id="the-query-dag"><h3>The query DAG</h3></a>
<p>The query DAG code is stored in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph"><code>src/librustc/dep_graph</code></a>. Construction of the DAG is done
by instrumenting the query execution.</p>
<p>One key point is that the query DAG also tracks ordering; that is, for
each query Q, we not only track the queries that Q reads, we track the
<strong>order</strong> in which they were read.  This allows try-mark-green to walk
those queries back in the same order. This is important because once a subquery comes back as red,
we can no longer be sure that Q will continue along the same path as before.
That is, imagine a query like this:</p>
<pre><code class="language-rust ignore">fn main_query(tcx) {
    if tcx.subquery1() {
        tcx.subquery2()
    } else {
        tcx.subquery3()
    }
}
</code></pre>
<p>Now imagine that in the first compilation, <code>main_query</code> starts by
executing <code>subquery1</code>, and this returns true. In that case, the next
query <code>main_query</code> executes will be <code>subquery2</code>, and <code>subquery3</code> will
not be executed at all.</p>
<p>But now imagine that in the <strong>next</strong> compilation, the input has
changed such that <code>subquery1</code> returns <strong>false</strong>. In this case, <code>subquery2</code> would never
execute. If try-mark-green were to visit <code>reads(main_query)</code> out of order,
however, it might visit <code>subquery2</code> before <code>subquery1</code>, and hence execute it.
This can lead to ICEs and other problems in the compiler.</p>
<a class="header" href="print.html#improvements-to-the-basic-algorithm" id="improvements-to-the-basic-algorithm"><h2>Improvements to the basic algorithm</h2></a>
<p>In the description basic algorithm, we said that at the end of
compilation we would save the results of all the queries that were
performed.  In practice, this can be quite wasteful – many of those
results are very cheap to recompute, and serializing and deserializing
them is not a particular win. In practice, what we would do is to save
<strong>the hashes</strong> of all the subqueries that we performed. Then, in select cases,
we <strong>also</strong> save the results.</p>
<p>This is why the incremental algorithm separates computing the
<strong>color</strong> of a node, which often does not require its value, from
computing the <strong>result</strong> of a node. Computing the result is done via a simple algorithm
like so:</p>
<ul>
<li>Check if a saved result for Q is available. If so, compute the color of Q.
If Q is green, deserialize and return the saved result.</li>
<li>Otherwise, execute Q.
<ul>
<li>We can then compare the hash of the result and color Q as green if
it did not change.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#footnotes" id="footnotes"><h1>Footnotes</h1></a>
<div class="footnote-definition" id="salsa"><sup class="footnote-definition-label">1</sup>
<p>I have long wanted to rename it to the Salsa algorithm, but it never caught on. -@nikomatsakis</p>
</div>
<a class="header" href="print.html#the-parser" id="the-parser"><h1>The Parser</h1></a>
<p>The parser is responsible for converting raw Rust source code into a structured
form which is easier for the compiler to work with, usually called an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>Abstract
Syntax Tree</em></a>. An AST mirrors the structure of a Rust program in memory,
using a <code>Span</code> to link a particular AST node back to its source text.</p>
<p>The bulk of the parser lives in the <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax">libsyntax</a> crate.</p>
<p>Like most parsers, the parsing process is composed of two main steps,</p>
<ul>
<li>lexical analysis – turn a stream of characters into a stream of token trees</li>
<li>parsing – turn the token trees into an AST</li>
</ul>
<p>The <code>syntax</code> crate contains several main players,</p>
<ul>
<li>a <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/codemap.rs"><code>CodeMap</code></a> for mapping AST nodes to their source code</li>
<li>the <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/ast.rs">ast module</a> contains types corresponding to each AST node</li>
<li>a <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/lexer/mod.rs"><code>StringReader</code></a> for lexing source code into tokens</li>
<li>the <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/parse">parser module</a> and <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs"><code>Parser</code></a> struct are in charge of actually parsing
tokens into AST nodes,</li>
<li>and a <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/visit.rs">visit module</a> for walking the AST and inspecting or mutating the AST
nodes.</li>
</ul>
<p>The main entrypoint to the parser is via the various <code>parse_*</code> functions
in the <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/parse">parser module</a>. They let you do things like turn a filemap into a
token stream, create a parser from the token stream, and then execute the
parser to get a <code>Crate</code> (the root AST node).</p>
<p>To minimise the amount of copying that is done, both the <code>StringReader</code> and
<code>Parser</code> have lifetimes which bind them to the parent <code>ParseSess</code>. This contains
all the information needed while parsing, as well as the <code>CodeMap</code> itself.</p>
<a class="header" href="print.html#macro-expansion" id="macro-expansion"><h1>Macro expansion</h1></a>
<p>Macro expansion happens during parsing. <code>rustc</code> has two parsers, in fact: the
normal Rust parser, and the macro parser. During the parsing phase, the normal
Rust parser will set aside the contents of macros and their invokations. Later,
before name resolution, macros are expanded using these portions of the code.
The macro parser, in turn, may call the normal Rust parser when it needs to
bind a metavariable (e.g.  <code>$my_expr</code>) while parsing the contents of a macro
invocation. The code for macro expansion is in
<a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/ext/tt"><code>src/libsyntax/ext/tt/</code></a>. This chapter aims to explain how macro
expansion works.</p>
<a class="header" href="print.html#example" id="example"><h3>Example</h3></a>
<p>It's helpful to have an example to refer to. For the remainder of this chapter,
whenever we refer to the &quot;example <em>definition</em>&quot;, we mean the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! printer {
    (print $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
    }
    (print twice $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
        println!(&quot;{}&quot;, $mvar);
    }
}
#}</code></pre></pre>
<p><code>$mvar</code> is called a <em>metavariable</em>. Unlike normal variables, rather than
binding to a value in a computation, a metavariable binds <em>at compile time</em> to
a tree of <em>tokens</em>.  A <em>token</em> is a single &quot;unit&quot; of the grammar, such as an
identifier (e.g. <code>foo</code>) or punctuation (e.g. <code>=&gt;</code>). There are also other
special tokens, such as <code>EOF</code>, which indicates that there are no more tokens.
Token trees resulting from paired parentheses-like characters (<code>(</code>...<code>)</code>,
<code>[</code>...<code>]</code>, and <code>{</code>...<code>}</code>) – they include the open and close and all the tokens
in between (we do require that parentheses-like characters be balanced). Having
macro expansion operate on token streams rather than the raw bytes of a source
file abstracts away a lot of complexity. The macro expander (and much of the
rest of the compiler) doesn't really care that much about the exact line and
column of some syntactic construct in the code; it cares about what constructs
are used in the code. Using tokens allows us to care about <em>what</em> without
worrying about <em>where</em>. For more information about tokens, see the
<a href="./the-parser.html">Parsing</a> chapter of this book.</p>
<p>Whenever we refer to the &quot;example <em>invocation</em>&quot;, we mean the following snippet:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
printer!(print foo); // Assume `foo` is a variable defined somewhere else...
#}</code></pre></pre>
<p>The process of expanding the macro invocation into the syntax tree
<code>println!(&quot;{}&quot;, foo)</code> and then expanding that into a call to <code>Display::fmt</code> is
called <em>macro expansion</em>, and it is the topic of this chapter.</p>
<a class="header" href="print.html#the-macro-parser" id="the-macro-parser"><h3>The macro parser</h3></a>
<p>There are two parts to macro expansion: parsing the definition and parsing the
invocations. Interestingly, both are done by the macro parser.</p>
<p>Basically, the macro parser is like an NFA-based regex parser. It uses an
algorithm similar in spirit to the <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsing
algorithm</a>. The macro parser is
defined in <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/ext/tt/macro_parser.rs"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<p>The interface of the macro parser is as follows (this is slightly simplified):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn parse(
    sess: ParserSession,
    tts: TokenStream,
    ms: &amp;[TokenTree]
) -&gt; NamedParseResult
#}</code></pre></pre>
<p>In this interface:</p>
<ul>
<li><code>sess</code> is a &quot;parsing session&quot;, which keeps track of some metadata. Most
notably, this is used to keep track of errors that are generated so they can
be reported to the user.</li>
<li><code>tts</code> is a stream of tokens. The macro parser's job is to consume the raw
stream of tokens and output a binding of metavariables to corresponding token
trees.</li>
<li><code>ms</code> a <em>matcher</em>. This is a sequence of token trees that we want to match
<code>tts</code> against.</li>
</ul>
<p>In the analogy of a regex parser, <code>tts</code> is the input and we are matching it
against the pattern <code>ms</code>. Using our examples, <code>tts</code> could be the stream of
tokens containing the inside of the example invocation <code>print foo</code>, while <code>ms</code>
might be the sequence of token (trees) <code>print $mvar:ident</code>.</p>
<p>The output of the parser is a <code>NamedParserResult</code>, which indicates which of
three cases has occured:</p>
<ul>
<li>Success: <code>tts</code> matches the given matcher <code>ms</code>, and we have produced a binding
from metavariables to the corresponding token trees.</li>
<li>Failure: <code>tts</code> does not match <code>ms</code>. This results in an error message such as
&quot;No rule expected token <em>blah</em>&quot;.</li>
<li>Error: some fatal error has occured <em>in the parser</em>. For example, this happens
if there are more than one pattern match, since that indicates the macro is
ambiguous.</li>
</ul>
<p>The full interface is defined <a href="https://github.com/rust-lang/rust/blob/a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82/src/libsyntax/ext/tt/macro_parser.rs#L421">here</a>.</p>
<p>The macro parser does pretty much exactly the same as a normal regex parser with
one exception: in order to parse different types of metavariables, such as
<code>ident</code>, <code>block</code>, <code>expr</code>, etc., the macro parser must sometimes call back to the
normal Rust parser.</p>
<p>As mentioned above, both definitions and invocations of macros are parsed using
the macro parser. This is extremely non-intuitive and self-referential. The code
to parse macro <em>definitions</em> is in
<a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/ext/tt/macro_rules.rs"><code>src/libsyntax/ext/tt/macro_rules.rs</code></a>. It defines the pattern for
matching for a macro definition as <code>$( $lhs:tt =&gt; $rhs:tt );+</code>. In other words,
a <code>macro_rules</code> defintion should have in its body at least one occurence of a
token tree followed by <code>=&gt;</code> followed by another token tree. When the compiler
comes to a <code>macro_rules</code> definition, it uses this pattern to match the two token
trees per rule in the definition of the macro <em>using the macro parser itself</em>.
In our example definition, the metavariable <code>$lhs</code> would match the patterns of
both arms: <code>(print $mvar:ident)</code> and <code>(print twice $mvar:ident)</code>.  And <code>$rhs</code>
would match the bodies of both arms: <code>{ println!(&quot;{}&quot;, $mvar); }</code> and <code>{ println!(&quot;{}&quot;, $mvar); println!(&quot;{}&quot;, $mvar); }</code>. The parser would keep this
knowledge around for when it needs to expand a macro invocation.</p>
<p>When the compiler comes to a macro invocation, it parses that invocation using
the same NFA-based macro parser that is described above. However, the matcher
used is the first token tree (<code>$lhs</code>) extracted from the arms of the macro
<em>definition</em>. Using our example, we would try to match the token stream <code>print foo</code> from the invocation against the matchers <code>print $mvar:ident</code> and <code>print twice $mvar:ident</code> that we previously extracted from the definition.  The
algorithm is exactly the same, but when the macro parser comes to a place in the
current matcher where it needs to match a <em>non-terminal</em> (e.g. <code>$mvar:ident</code>),
it calls back to the normal Rust parser to get the contents of that
non-terminal. In this case, the Rust parser would look for an <code>ident</code> token,
which it finds (<code>foo</code>) and returns to the macro parser. Then, the macro parser
proceeds in parsing as normal. Also, note that exactly one of the matchers from
the various arms should match the invocation; if there is more than one match,
the parse is ambiguous, while if there are no matches at all, there is a syntax
error.</p>
<p>For more information about the macro parser's implementation, see the comments
in <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/ext/tt/macro_parser.rs"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<a class="header" href="print.html#hygiene" id="hygiene"><h3>Hygiene</h3></a>
<p>TODO</p>
<a class="header" href="print.html#procedural-macros" id="procedural-macros"><h3>Procedural Macros</h3></a>
<p>TODO</p>
<a class="header" href="print.html#custom-derive" id="custom-derive"><h3>Custom Derive</h3></a>
<p>TODO</p>
<a class="header" href="print.html#name-resolution" id="name-resolution"><h1>Name resolution</h1></a>
<p>The name resolution is a separate pass in the compiler. Its input is the syntax
tree, produced by parsing input files. It produces links from all the names in
the source to relevant places where the name was introduced. It also generates
helpful error messages, like typo suggestions or traits to import.</p>
<p>The name resolution lives in the <code>librustc_resolve</code> crate, with the meat in
<code>lib.rs</code> and some helpers or symbol-type specific logic in the other modules.</p>
<a class="header" href="print.html#namespaces" id="namespaces"><h2>Namespaces</h2></a>
<p>Different kind of symbols live in different namespaces ‒ eg. types don't
clash with variables. This usually doesn't happen, because variables start with
lower-case letter while types with upper case one, but this is only a
convention. This is legal Rust code that'll compile (with warnings):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type x = u32;
let x: x = 1;
let y: x = 2; // See? x is still a type here.
#}</code></pre></pre>
<p>To cope with this, and with slightly different scoping rules for these
namespaces, the resolver keeps them separated and builds separate structures for
them.</p>
<p>In other words, when the code talks about namespaces, it doesn't mean the module
hierarchy, it's types vs. values vs. macros.</p>
<a class="header" href="print.html#scopes-and-ribs" id="scopes-and-ribs"><h2>Scopes and ribs</h2></a>
<p>A name is visible only in certain area in the source code. This forms a
hierarchical structure, but not necessarily a simple one ‒ if one scope is part
of another, it doesn't mean the name visible in the outer one is also visible in
the inner one, or that it refers to the same thing.</p>
<p>To cope with that, the compiler introduces the concept of Ribs. This is
abstraction of a scope. Every time the set of visible names potentially changes,
a new rib is pushed onto a stack. The places where this can happen includes for
example:</p>
<ul>
<li>The obvious places ‒ curly braces enclosing a block, function boundaries,
modules.</li>
<li>Introducing a let binding ‒ this can shadow another binding with the same
name.</li>
<li>Macro expansion border ‒ to cope with macro hygiene.</li>
</ul>
<p>When searching for a name, the stack of ribs is traversed from the innermost
outwards. This helps to find the closest meaning of the name (the one not
shadowed by anything else). The transition to outer rib may also change the
rules what names are usable ‒ if there are nested functions (not closures), the
inner one can't access parameters and local bindings of the outer one, even
though they should be visible by ordinary scoping rules. An example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn do_something&lt;T: Default&gt;(val: T) { // &lt;- New rib in both types and values (1)
    // `val` is accessible, as is the helper function
    // `T` is accessible
    let helper = || { // New rib on `helper` (2) and another on the block (3)
        // `val` is accessible here
    }; // End of (3)
    // `val` is accessible, `helper` variable shadows `helper` function
    fn helper() { // &lt;- New rib in both types and values (4)
        // `val` is not accessible here, (4) is not transparent for locals)
        // `T` is not accessible here
    } // End of (4)
    let val = T::default(); // New rib (5)
    // `val` is the variable, not the parameter here
} // End of (5), (2) and (1)
#}</code></pre></pre>
<p>Because the rules for different namespaces are a bit different, each namespace
has its own independent rib stack that is constructed in parallel to the others.</p>
<a class="header" href="print.html#overall-strategy" id="overall-strategy"><h2>Overall strategy</h2></a>
<p>To perform the name resolution of the whole crate, the syntax tree is traversed
top-down and every encountered name is resolved. This works for most kinds of
names, because at the point of use of a name it is already introduced in the Rib
hierarchy.</p>
<p>There are some exceptions to this. Items are bit tricky, because they can be
used even before encountered ‒ therefore every block needs to be first scanned
for items to fill in its Rib.</p>
<p>Other, even more problematic ones, are imports which need recursive fixed-point
resolution and macros, that need to be resolved and expanded before the rest of
the code can be processed.</p>
<p>Therefore, the resolution is performed in multiple stages.</p>
<a class="header" href="print.html#todo" id="todo"><h2>TODO:</h2></a>
<p>This is a result of the first pass of learning the code. It is definitely
incomplete and not detailed enough. It also might be inaccurate in places.
Still, it probably provides useful first guidepost to what happens in there.</p>
<ul>
<li>What exactly does it link to and how is that published and consumed by
following stages of compilation?</li>
<li>Who calls it and how it is actually used.</li>
<li>Is it a pass and then the result is only used, or can it be computed
incrementally (eg. for RLS)?</li>
<li>The overall strategy description is a bit vague.</li>
<li>Where does the name <code>Rib</code> come from?</li>
<li>Does this thing have its own tests, or is it tested only as part of some e2e
testing?</li>
</ul>
<a class="header" href="print.html#the-hir" id="the-hir"><h1>The HIR</h1></a>
<p>The HIR – &quot;High-level IR&quot; – is the primary IR used in most of rustc.
It is a desugared version of the &quot;abstract syntax tree&quot; (AST) that is generated
after parsing, macro expansion, and name resolution have completed. Many parts
of HIR resemble Rust surface syntax quite closely, with the exception that some
of Rust's expression forms have been desugared away (as an example, <code>for</code> loops
are converted into a <code>loop</code> and do not appear in the HIR).</p>
<p>This chapter covers the main concepts of the HIR.</p>
<a class="header" href="print.html#out-of-band-storage-and-the-crate-type" id="out-of-band-storage-and-the-crate-type"><h3>Out-of-band storage and the <code>Crate</code> type</h3></a>
<p>The top-level data-structure in the HIR is the <code>Crate</code>, which stores
the contents of the crate currently being compiled (we only ever
construct HIR for the current crate). Whereas in the AST the crate
data structure basically just contains the root module, the HIR
<code>Crate</code> structure contains a number of maps and other things that
serve to organize the content of the crate for easier access.</p>
<p>For example, the contents of individual items (e.g. modules,
functions, traits, impls, etc) in the HIR are not immediately
accessible in the parents. So, for example, if there is a module item
<code>foo</code> containing a function <code>bar()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    fn bar() { }
}
#}</code></pre></pre>
<p>then in the HIR the representation of module <code>foo</code> (the <code>Mod</code>
stuct) would only have the <strong><code>ItemId</code></strong> <code>I</code> of <code>bar()</code>. To get the
details of the function <code>bar()</code>, we would lookup <code>I</code> in the
<code>items</code> map.</p>
<p>One nice result from this representation is that one can iterate
over all items in the crate by iterating over the key-value pairs
in these maps (without the need to trawl through the whole HIR).
There are similar maps for things like trait items and impl items,
as well as &quot;bodies&quot; (explained below).</p>
<p>The other reason to set up the representation this way is for better
integration with incremental compilation. This way, if you gain access
to an <code>&amp;hir::Item</code> (e.g. for the mod <code>foo</code>), you do not immediately
gain access to the contents of the function <code>bar()</code>. Instead, you only
gain access to the <strong>id</strong> for <code>bar()</code>, and you must invoke some
function to lookup the contents of <code>bar()</code> given its id; this gives the
compiler a chance to observe that you accessed the data for <code>bar()</code>,
and then record the dependency.</p>
<a class="header" href="print.html#identifiers-in-the-hir" id="identifiers-in-the-hir"><h3>Identifiers in the HIR</h3></a>
<p>Most of the code that has to deal with things in HIR tends not to
carry around references into the HIR, but rather to carry around
<em>identifier numbers</em> (or just &quot;ids&quot;). Right now, you will find four
sorts of identifiers in active use:</p>
<ul>
<li><code>DefId</code> – primarily names &quot;definitions&quot; or top-level items.
<ul>
<li>You can think of a <code>DefId</code> as shorthand for a very explicit and complete
path, like <code>std::collections::HashMap</code>. However, these paths are able to
name things that are not nameable in normal Rust (e.g. <code>impl</code>s), and they
also include extra information about the crate (such as its version number,
since two versions of the same crate can co-exist).</li>
<li>A <code>DefId</code> really consists of two parts, a <code>CrateNum</code> (which identifies the
crate) and a <code>DefIndex</code> (which indexes into a list of items that is
maintained per crate).</li>
</ul>
</li>
<li><code>HirId</code> – combines the index of a particular item with an offset within
that item.
<ul>
<li>The key point of an <code>HirId</code> is that it is <em>relative</em> to some item (which is
named via a <code>DefId</code>).</li>
</ul>
</li>
<li><code>BodyId</code> – an absolute identifier that refers to a specific body (definition
of a function or constant) in the crate. It is currently effectively a
&quot;newtype'd&quot; <code>NodeId</code>.</li>
<li><code>NodeId</code> – an absolute ID that identifies a single node in the HIR tree.
<ul>
<li>While these are still in common use, <strong>they are being slowly phased out</strong>.</li>
<li>Since they are absolute within the crate, adding a new node anywhere in the
tree causes the <code>NodeId</code>s of all subsequent code in the crate to change.
This is terrible for incremental compilation, as you can perhaps imagine.</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#the-hir-map" id="the-hir-map"><h3>The HIR Map</h3></a>
<p>Most of the time when you are working with the HIR, you will do so via
the <strong>HIR Map</strong>, accessible in the tcx via <code>tcx.hir</code> (and defined in
the <code>hir::map</code> module). The HIR map contains a number of methods to
convert between IDs of various kinds and to lookup data associated
with an HIR node.</p>
<p>For example, if you have a <code>DefId</code>, and you would like to convert it
to a <code>NodeId</code>, you can use <code>tcx.hir.as_local_node_id(def_id)</code>. This
returns an <code>Option&lt;NodeId&gt;</code> – this will be <code>None</code> if the def-id
refers to something outside of the current crate (since then it has no
HIR node), but otherwise returns <code>Some(n)</code> where <code>n</code> is the node-id of
the definition.</p>
<p>Similarly, you can use <code>tcx.hir.find(n)</code> to lookup the node for a
<code>NodeId</code>. This returns a <code>Option&lt;Node&lt;'tcx&gt;&gt;</code>, where <code>Node</code> is an enum
defined in the map; by matching on this you can find out what sort of
node the node-id referred to and also get a pointer to the data
itself. Often, you know what sort of node <code>n</code> is – e.g. if you know
that <code>n</code> must be some HIR expression, you can do
<code>tcx.hir.expect_expr(n)</code>, which will extract and return the
<code>&amp;hir::Expr</code>, panicking if <code>n</code> is not in fact an expression.</p>
<p>Finally, you can use the HIR map to find the parents of nodes, via
calls like <code>tcx.hir.get_parent_node(n)</code>.</p>
<a class="header" href="print.html#hir-bodies" id="hir-bodies"><h3>HIR Bodies</h3></a>
<p>A <strong>body</strong> represents some kind of executable code, such as the body
of a function/closure or the definition of a constant. Bodies are
associated with an <strong>owner</strong>, which is typically some kind of item
(e.g. an <code>fn()</code> or <code>const</code>), but could also be a closure expression
(e.g. <code>|x, y| x + y</code>). You can use the HIR map to find the body
associated with a given <code>DefId</code> (<code>maybe_body_owned_by()</code>) or to find
the owner of a body (<code>body_owner_def_id()</code>).</p>
<a class="header" href="print.html#the-ty-module-representing-types" id="the-ty-module-representing-types"><h1>The <code>ty</code> module: representing types</h1></a>
<p>The <code>ty</code> module defines how the Rust compiler represents types
internally. It also defines the <em>typing context</em> (<code>tcx</code> or <code>TyCtxt</code>),
which is the central data structure in the compiler.</p>
<a class="header" href="print.html#the-tcx-and-how-it-uses-lifetimes" id="the-tcx-and-how-it-uses-lifetimes"><h2>The tcx and how it uses lifetimes</h2></a>
<p>The <code>tcx</code> (&quot;typing context&quot;) is the central data structure in the
compiler. It is the context that you use to perform all manner of
queries. The struct <code>TyCtxt</code> defines a reference to this shared context:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tcx: TyCtxt&lt;'a, 'gcx, 'tcx&gt;
//          --  ----  ----
//          |   |     |
//          |   |     innermost arena lifetime (if any)
//          |   &quot;global arena&quot; lifetime
//          lifetime of this reference
#}</code></pre></pre>
<p>As you can see, the <code>TyCtxt</code> type takes three lifetime parameters.
These lifetimes are perhaps the most complex thing to understand about
the tcx. During Rust compilation, we allocate most of our memory in
<strong>arenas</strong>, which are basically pools of memory that get freed all at
once. When you see a reference with a lifetime like <code>'tcx</code> or <code>'gcx</code>,
you know that it refers to arena-allocated data (or data that lives as
long as the arenas, anyhow).</p>
<p>We use two distinct levels of arenas. The outer level is the &quot;global
arena&quot;. This arena lasts for the entire compilation: so anything you
allocate in there is only freed once compilation is basically over
(actually, when we shift to executing LLVM).</p>
<p>To reduce peak memory usage, when we do type inference, we also use an
inner level of arena. These arenas get thrown away once type inference
is over. This is done because type inference generates a lot of
&quot;throw-away&quot; types that are not particularly interesting after type
inference completes, so keeping around those allocations would be
wasteful.</p>
<p>Often, we wish to write code that explicitly asserts that it is not
taking place during inference. In that case, there is no &quot;local&quot;
arena, and all the types that you can access are allocated in the
global arena.  To express this, the idea is to use the same lifetime
for the <code>'gcx</code> and <code>'tcx</code> parameters of <code>TyCtxt</code>. Just to be a touch
confusing, we tend to use the name <code>'tcx</code> in such contexts. Here is an
example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn not_in_inference&lt;'a, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'tcx, 'tcx&gt;, def_id: DefId) {
    //                                        ----  ----
    //                                        Using the same lifetime here asserts
    //                                        that the innermost arena accessible through
    //                                        this reference *is* the global arena.
}
#}</code></pre></pre>
<p>In contrast, if we want to code that can be usable during type inference, then you
need to declare a distinct <code>'gcx</code> and <code>'tcx</code> lifetime parameter:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn maybe_in_inference&lt;'a, 'gcx, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'gcx, 'tcx&gt;, def_id: DefId) {
    //                                                ----  ----
    //                                        Using different lifetimes here means that
    //                                        the innermost arena *may* be distinct
    //                                        from the global arena (but doesn't have to be).
}
#}</code></pre></pre>
<a class="header" href="print.html#allocating-and-working-with-types" id="allocating-and-working-with-types"><h3>Allocating and working with types</h3></a>
<p>Rust types are represented using the <code>Ty&lt;'tcx&gt;</code> defined in the <code>ty</code>
module (not to be confused with the <code>Ty</code> struct from <a href="./hir.html">the HIR</a>). This
is in fact a simple type alias for a reference with <code>'tcx</code> lifetime:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type Ty&lt;'tcx&gt; = &amp;'tcx TyS&lt;'tcx&gt;;
#}</code></pre></pre>
<p>You can basically ignore the <code>TyS</code> struct – you will basically never
access it explicitly. We always pass it by reference using the
<code>Ty&lt;'tcx&gt;</code> alias – the only exception I think is to define inherent
methods on types. Instances of <code>TyS</code> are only ever allocated in one of
the rustc arenas (never e.g. on the stack).</p>
<p>One common operation on types is to <strong>match</strong> and see what kinds of
types they are. This is done by doing <code>match ty.sty</code>, sort of like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn test_type&lt;'tcx&gt;(ty: Ty&lt;'tcx&gt;) {
    match ty.sty {
        ty::TyArray(elem_ty, len) =&gt; { ... }
        ...
    }
}
#}</code></pre></pre>
<p>The <code>sty</code> field (the origin of this name is unclear to me; perhaps
structural type?) is of type <code>TypeVariants&lt;'tcx&gt;</code>, which is an enum
defining all of the different kinds of types in the compiler.</p>
<blockquote>
<p>N.B. inspecting the <code>sty</code> field on types during type inference can be
risky, as there may be inference variables and other things to
consider, or sometimes types are not yet known that will become
known later.).</p>
</blockquote>
<p>To allocate a new type, you can use the various <code>mk_</code> methods defined
on the <code>tcx</code>. These have names that correpond mostly to the various kinds
of type variants. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let array_ty = tcx.mk_array(elem_ty, len * 2);
#}</code></pre></pre>
<p>These methods all return a <code>Ty&lt;'tcx&gt;</code> – note that the lifetime you
get back is the lifetime of the innermost arena that this <code>tcx</code> has
access to. In fact, types are always canonicalized and interned (so we
never allocate exactly the same type twice) and are always allocated
in the outermost arena where they can be (so, if they do not contain
any inference variables or other &quot;temporary&quot; types, they will be
allocated in the global arena). However, the lifetime <code>'tcx</code> is always
a safe approximation, so that is what you get back.</p>
<blockquote>
<p>NB. Because types are interned, it is possible to compare them for
equality efficiently using <code>==</code> – however, this is almost never what
you want to do unless you happen to be hashing and looking for
duplicates. This is because often in Rust there are multiple ways to
represent the same type, particularly once inference is involved. If
you are going to be testing for type equality, you probably need to
start looking into the inference code to do it right.</p>
</blockquote>
<p>You can also find various common types in the <code>tcx</code> itself by accessing
<code>tcx.types.bool</code>, <code>tcx.types.char</code>, etc (see <code>CommonTypes</code> for more).</p>
<a class="header" href="print.html#beyond-types-other-kinds-of-arena-allocated-data-structures" id="beyond-types-other-kinds-of-arena-allocated-data-structures"><h3>Beyond types: other kinds of arena-allocated data structures</h3></a>
<p>In addition to types, there are a number of other arena-allocated data
structures that you can allocate, and which are found in this
module. Here are a few examples:</p>
<ul>
<li><code>Substs</code>, allocated with <code>mk_substs</code> – this will intern a slice of types, often used to
specify the values to be substituted for generics (e.g. <code>HashMap&lt;i32, u32&gt;</code>
would be represented as a slice <code>&amp;'tcx [tcx.types.i32, tcx.types.u32]</code>).</li>
<li><code>TraitRef</code>, typically passed by value – a <strong>trait reference</strong>
consists of a reference to a trait along with its various type
parameters (including <code>Self</code>), like <code>i32: Display</code> (here, the def-id
would reference the <code>Display</code> trait, and the substs would contain
<code>i32</code>).</li>
<li><code>Predicate</code> defines something the trait system has to prove (see <code>traits</code> module).</li>
</ul>
<a class="header" href="print.html#import-conventions" id="import-conventions"><h3>Import conventions</h3></a>
<p>Although there is no hard and fast rule, the <code>ty</code> module tends to be used like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use ty::{self, Ty, TyCtxt};
#}</code></pre></pre>
<p>In particular, since they are so common, the <code>Ty</code> and <code>TyCtxt</code> types
are imported directly. Other types are often referenced with an
explicit <code>ty::</code> prefix (e.g. <code>ty::TraitRef&lt;'tcx&gt;</code>). But some modules
choose to import a larger or smaller set of names explicitly.</p>
<a class="header" href="print.html#type-inference" id="type-inference"><h1>Type inference</h1></a>
<p>The type inference is based on the standard Hindley-Milner (HM) type inference
algorithm, but extended in various way to accommodate subtyping, region
inference, and higher-ranked types.</p>
<a class="header" href="print.html#a-note-on-terminology" id="a-note-on-terminology"><h2>A note on terminology</h2></a>
<p>We use the notation <code>?T</code> to refer to inference variables, also called
existential variables.</p>
<p>We use the terms &quot;region&quot; and &quot;lifetime&quot; interchangeably. Both refer to
the <code>'a</code> in <code>&amp;'a T</code>.</p>
<p>The term &quot;bound region&quot; refers to a region that is bound in a function
signature, such as the <code>'a</code> in <code>for&lt;'a&gt; fn(&amp;'a u32)</code>. A region is
&quot;free&quot; if it is not bound.</p>
<a class="header" href="print.html#creating-an-inference-context" id="creating-an-inference-context"><h2>Creating an inference context</h2></a>
<p>You create and &quot;enter&quot; an inference context by doing something like
the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
tcx.infer_ctxt().enter(|infcx| {
    // Use the inference context `infcx` here.
})
#}</code></pre></pre>
<p>Each inference context creates a short-lived type arena to store the
fresh types and things that it will create, as described in the
<a href="ty.html">chapter on the <code>ty</code> module</a>. This arena is created by the <code>enter</code>
function and disposed of after it returns.</p>
<p>Within the closure, <code>infcx</code> has the type <code>InferCtxt&lt;'cx, 'gcx, 'tcx&gt;</code>
for some fresh <code>'cx</code> and <code>'tcx</code> – the latter corresponds to the lifetime of
this temporary arena, and the <code>'cx</code> is the lifetime of the <code>InferCtxt</code> itself.
(Again, see the <a href="ty.html"><code>ty</code> chapter</a> for more details on this setup.)</p>
<p>The <code>tcx.infer_ctxt</code> method actually returns a build, which means
there are some kinds of configuration you can do before the <code>infcx</code> is
created. See <code>InferCtxtBuilder</code> for more information.</p>
<a class="header" href="print.html#inference-variables" id="inference-variables"><h2>Inference variables</h2></a>
<p>The main purpose of the inference context is to house a bunch of
<strong>inference variables</strong> – these represent types or regions whose precise
value is not yet known, but will be uncovered as we perform type-checking.</p>
<p>If you're familiar with the basic ideas of unification from H-M type
systems, or logic languages like Prolog, this is the same concept. If
you're not, you might want to read a tutorial on how H-M type
inference works, or perhaps this blog post on
<a href="http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">unification in the Chalk project</a>.</p>
<p>All said, the inference context stores four kinds of inference variables as of
writing:</p>
<ul>
<li>Type variables, which come in three varieties:
<ul>
<li>General type variables (the most common). These can be unified with any type.</li>
<li>Integral type variables, which can only be unified with an integral type, and
arise from an integer literal expression like <code>22</code>.</li>
<li>Float type variables, which can only be unified with a float type, and
arise from a float literal expression like <code>22.0</code>.</li>
</ul>
</li>
<li>Region variables, which represent lifetimes, and arise all over the place.</li>
</ul>
<p>All the type variables work in much the same way: you can create a new
type variable, and what you get is <code>Ty&lt;'tcx&gt;</code> representing an
unresolved type <code>?T</code>. Then later you can apply the various operations
that the inferencer supports, such as equality or subtyping, and it
will possibly <strong>instantiate</strong> (or <strong>bind</strong>) that <code>?T</code> to a specific
value as a result.</p>
<p>The region variables work somewhat differently, and are described
below in a separate section.</p>
<a class="header" href="print.html#enforcing-equality--subtyping" id="enforcing-equality--subtyping"><h2>Enforcing equality / subtyping</h2></a>
<p>The most basic operations you can perform in the type inferencer is
<strong>equality</strong>, which forces two types <code>T</code> and <code>U</code> to be the same. The
recommended way to add an equality constraint is using the <code>at</code>
method, roughly like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
infcx.at(...).eq(t, u);
#}</code></pre></pre>
<p>The first <code>at()</code> call provides a bit of context, i.e. why you are
doing this unification, and in what environment, and the <code>eq</code> method
performs the actual equality constraint.</p>
<p>When you equate things, you force them to be precisely equal. Equating
returns an <code>InferResult</code> – if it returns <code>Err(err)</code>, then equating
failed, and the enclosing <code>TypeError</code> will tell you what went wrong.</p>
<p>The success case is perhaps more interesting. The &quot;primary&quot; return
type of <code>eq</code> is <code>()</code> – that is, when it succeeds, it doesn't return a
value of any particular interest. Rather, it is executed for its
side-effects of constraining type variables and so forth. However, the
actual return type is not <code>()</code>, but rather <code>InferOk&lt;()&gt;</code>. The
<code>InferOk</code> type is used to carry extra trait obligations – your job is
to ensure that these are fulfilled (typically by enrolling them in a
fulfillment context). See the <a href="trait-resolution.html">trait chapter</a> for more background on that.</p>
<p>You can similarly enforce subtyping through <code>infcx.at(..).sub(..)</code>. The same
basic concepts as above apply.</p>
<a class="header" href="print.html#trying-equality" id="trying-equality"><h2>&quot;Trying&quot; equality</h2></a>
<p>Sometimes you would like to know if it is <em>possible</em> to equate two
types without error.  You can test that with <code>infcx.can_eq</code> (or
<code>infcx.can_sub</code> for subtyping). If this returns <code>Ok</code>, then equality
is possible – but in all cases, any side-effects are reversed.</p>
<p>Be aware, though, that the success or failure of these methods is always
<strong>modulo regions</strong>. That is, two types <code>&amp;'a u32</code> and <code>&amp;'b u32</code> will
return <code>Ok</code> for <code>can_eq</code>, even if <code>'a != 'b</code>.  This falls out from the
&quot;two-phase&quot; nature of how we solve region constraints.</p>
<a class="header" href="print.html#snapshots" id="snapshots"><h2>Snapshots</h2></a>
<p>As described in the previous section on <code>can_eq</code>, often it is useful
to be able to do a series of operations and then roll back their
side-effects. This is done for various reasons: one of them is to be
able to backtrack, trying out multiple possibilities before settling
on which path to take. Another is in order to ensure that a series of
smaller changes take place atomically or not at all.</p>
<p>To allow for this, the inference context supports a <code>snapshot</code> method.
When you call it, it will start recording changes that occur from the
operations you perform. When you are done, you can either invoke
<code>rollback_to</code>, which will undo those changes, or else <code>confirm</code>, which
will make the permanent. Snapshots can be nested as long as you follow
a stack-like discipline.</p>
<p>Rather than use snapshots directly, it is often helpful to use the
methods like <code>commit_if_ok</code> or <code>probe</code> that encapsulate higher-level
patterns.</p>
<a class="header" href="print.html#subtyping-obligations" id="subtyping-obligations"><h2>Subtyping obligations</h2></a>
<p>One thing worth discussing is subtyping obligations. When you force
two types to be a subtype, like <code>?T &lt;: i32</code>, we can often convert those
into equality constraints. This follows from Rust's rather limited notion
of subtyping: so, in the above case, <code>?T &lt;: i32</code> is equivalent to <code>?T = i32</code>.</p>
<p>However, in some cases we have to be more careful. For example, when
regions are involved. So if you have <code>?T &lt;: &amp;'a i32</code>, what we would do
is to first &quot;generalize&quot; <code>&amp;'a i32</code> into a type with a region variable:
<code>&amp;'?b i32</code>, and then unify <code>?T</code> with that (<code>?T = &amp;'?b i32</code>). We then
relate this new variable with the original bound:</p>
<pre><code>&amp;'?b i32 &lt;: &amp;'a i32
</code></pre>
<p>This will result in a region constraint (see below) of <code>'?b: 'a</code>.</p>
<p>One final interesting case is relating two unbound type variables,
like <code>?T &lt;: ?U</code>.  In that case, we can't make progress, so we enqueue
an obligation <code>Subtype(?T, ?U)</code> and return it via the <code>InferOk</code>
mechanism. You'll have to try again when more details about <code>?T</code> or
<code>?U</code> are known.</p>
<a class="header" href="print.html#region-constraints" id="region-constraints"><h2>Region constraints</h2></a>
<p>Regions are inferred somewhat differently from types. Rather than
eagerly unifying things, we simply collect constraints as we go, but
make (almost) no attempt to solve regions. These constraints have the
form of an &quot;outlives&quot; constraint:</p>
<pre><code>'a: 'b
</code></pre>
<p>Actually, the code tends to view them as a subregion relation, but it's the same
idea:</p>
<pre><code>'b &lt;= 'a
</code></pre>
<p>(There are various other kinds of constriants, such as &quot;verifys&quot;; see
the <code>region_constraints</code> module for details.)</p>
<p>There is one case where we do some amount of eager unification. If you have an equality constraint
between two regions</p>
<pre><code>'a = 'b
</code></pre>
<p>we will record that fact in a unification table. You can then use
<code>opportunistic_resolve_var</code> to convert <code>'b</code> to <code>'a</code> (or vice
versa). This is sometimes needed to ensure termination of fixed-point
algorithms.</p>
<a class="header" href="print.html#extracting-region-constraints" id="extracting-region-constraints"><h2>Extracting region constraints</h2></a>
<p>Ultimately, region constraints are only solved at the very end of
type-checking, once all other constraints are known. There are two
ways to solve region constraints right now: lexical and
non-lexical. Eventually there will only be one.</p>
<p>To solve <strong>lexical</strong> region constraints, you invoke
<code>resolve_regions_and_report_errors</code>.  This &quot;closes&quot; the region
constraint process and invoke the <code>lexical_region_resolve</code> code. Once
this is done, any further attempt to equate or create a subtyping
relationship will yield an ICE.</p>
<p>Non-lexical region constraints are not handled within the inference
context. Instead, the NLL solver (actually, the MIR type-checker)
invokes <code>take_and_reset_region_constraints</code> periodically. This
extracts all of the outlives constraints from the region solver, but
leaves the set of variables intact. This is used to get <em>just</em> the
region constraints that resulted from some particular point in the
program, since the NLL solver needs to know not just <em>what</em> regions
were subregions but <em>where</em>. Finally, the NLL solver invokes
<code>take_region_var_origins</code>, which &quot;closes&quot; the region constraint
process in the same way as normal solving.</p>
<a class="header" href="print.html#lexical-region-resolution" id="lexical-region-resolution"><h2>Lexical region resolution</h2></a>
<p>Lexical region resolution is done by initially assigning each region
variable to an empty value. We then process each outlives constraint
repeatedly, growing region variables until a fixed-point is reached.
Region variables can be grown using a least-upper-bound relation on
the region lattice in a fairly straightforward fashion.</p>
<a class="header" href="print.html#trait-resolution" id="trait-resolution"><h1>Trait resolution</h1></a>
<p>This document describes the general process and points out some non-obvious
things.</p>
<p><strong>WARNING:</strong> This material was moved verbatim from a rustc README, so
it may not &quot;fit&quot; the style of the guide until it is adapted.</p>
<a class="header" href="print.html#major-concepts" id="major-concepts"><h2>Major concepts</h2></a>
<p>Trait resolution is the process of pairing up an impl with each
reference to a trait. So, for example, if there is a generic function like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; { /*...*/ }
#}</code></pre></pre>
<p>and then a call to that function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;isize&gt; = clone_slice(&amp;[1, 2, 3])
#}</code></pre></pre>
<p>it is the job of trait resolution to figure out (in which case)
whether there exists an impl of <code>isize : Clone</code></p>
<p>Note that in some cases, like generic functions, we may not be able to
find a specific impl, but we can figure out that the caller must
provide an impl. To see what I mean, consider the body of <code>clone_slice</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; {
    let mut v = Vec::new();
    for e in &amp;x {
        v.push((*e).clone()); // (*)
    }
}
#}</code></pre></pre>
<p>The line marked <code>(*)</code> is only legal if <code>T</code> (the type of <code>*e</code>)
implements the <code>Clone</code> trait. Naturally, since we don't know what <code>T</code>
is, we can't find the specific impl; but based on the bound <code>T:Clone</code>,
we can say that there exists an impl which the caller must provide.</p>
<p>We use the term <em>obligation</em> to refer to a trait reference in need of
an impl.</p>
<a class="header" href="print.html#overview" id="overview"><h2>Overview</h2></a>
<p>Trait resolution consists of three major parts:</p>
<ul>
<li>
<p>SELECTION: Deciding how to resolve a specific obligation. For
example, selection might decide that a specific obligation can be
resolved by employing an impl which matches the self type, or by
using a parameter bound. In the case of an impl, Selecting one
obligation can create <em>nested obligations</em> because of where clauses
on the impl itself. It may also require evaluating those nested
obligations to resolve ambiguities.</p>
</li>
<li>
<p>FULFILLMENT: The fulfillment code is what tracks that obligations
are completely fulfilled. Basically it is a worklist of obligations
to be selected: once selection is successful, the obligation is
removed from the worklist and any nested obligations are enqueued.</p>
</li>
<li>
<p>COHERENCE: The coherence checks are intended to ensure that there
are never overlapping impls, where two impls could be used with
equal precedence.</p>
</li>
</ul>
<a class="header" href="print.html#selection" id="selection"><h2>Selection</h2></a>
<p>Selection is the process of deciding whether an obligation can be
resolved and, if so, how it is to be resolved (via impl, where clause, etc).
The main interface is the <code>select()</code> function, which takes an obligation
and returns a <code>SelectionResult</code>. There are three possible outcomes:</p>
<ul>
<li>
<p><code>Ok(Some(selection))</code> – yes, the obligation can be resolved, and
<code>selection</code> indicates how. If the impl was resolved via an impl,
then <code>selection</code> may also indicate nested obligations that are required
by the impl.</p>
</li>
<li>
<p><code>Ok(None)</code> – we are not yet sure whether the obligation can be
resolved or not. This happens most commonly when the obligation
contains unbound type variables.</p>
</li>
<li>
<p><code>Err(err)</code> – the obligation definitely cannot be resolved due to a
type error, or because there are no impls that could possibly apply,
etc.</p>
</li>
</ul>
<p>The basic algorithm for selection is broken into two big phases:
candidate assembly and confirmation.</p>
<a class="header" href="print.html#candidate-assembly" id="candidate-assembly"><h3>Candidate assembly</h3></a>
<p>Searches for impls/where-clauses/etc that might
possibly be used to satisfy the obligation. Each of those is called
a candidate. To avoid ambiguity, we want to find exactly one
candidate that is definitively applicable. In some cases, we may not
know whether an impl/where-clause applies or not – this occurs when
the obligation contains unbound inference variables.</p>
<p>The basic idea for candidate assembly is to do a first pass in which
we identify all possible candidates. During this pass, all that we do
is try and unify the type parameters. (In particular, we ignore any
nested where clauses.) Presuming that this unification succeeds, the
impl is added as a candidate.</p>
<p>Once this first pass is done, we can examine the set of candidates. If
it is a singleton set, then we are done: this is the only impl in
scope that could possibly apply. Otherwise, we can winnow down the set
of candidates by using where clauses and other conditions. If this
reduced set yields a single, unambiguous entry, we're good to go,
otherwise the result is considered ambiguous.</p>
<a class="header" href="print.html#the-basic-process-inferring-based-on-the-impls-we-see" id="the-basic-process-inferring-based-on-the-impls-we-see"><h4>The basic process: Inferring based on the impls we see</h4></a>
<p>This process is easier if we work through some examples. Consider
the following trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}
#}</code></pre></pre>
<p>This trait just has one method. It's about as simple as it gets. It
converts from the (implicit) <code>Self</code> type to the <code>Target</code> type. If we
wanted to permit conversion between <code>isize</code> and <code>usize</code>, we might
implement <code>Convert</code> like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Convert&lt;usize&gt; for isize { /*...*/ } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { /*...*/ } // usize -&gt; isize
#}</code></pre></pre>
<p>Now imagine there is some code like the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: isize = ...;
let y = x.convert();
#}</code></pre></pre>
<p>The call to convert will generate a trait reference <code>Convert&lt;$Y&gt; for isize</code>, where <code>$Y</code> is the type variable representing the type of
<code>y</code>. When we match this against the two impls we can see, we will find
that only one remains: <code>Convert&lt;usize&gt; for isize</code>. Therefore, we can
select this impl, which will cause the type of <code>$Y</code> to be unified to
<code>usize</code>. (Note that while assembling candidates, we do the initial
unifications in a transaction, so that they don't affect one another.)</p>
<p>There are tests to this effect in src/test/run-pass:</p>
<p>traits-multidispatch-infer-convert-source-and-target.rs
traits-multidispatch-infer-convert-target.rs</p>
<a class="header" href="print.html#winnowing-resolving-ambiguities" id="winnowing-resolving-ambiguities"><h4>Winnowing: Resolving ambiguities</h4></a>
<p>But what happens if there are multiple impls where all the types
unify? Consider this example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Get {
    fn get(&amp;self) -&gt; Self;
}

impl&lt;T:Copy&gt; Get for T {
    fn get(&amp;self) -&gt; T { *self }
}

impl&lt;T:Get&gt; Get for Box&lt;T&gt; {
    fn get(&amp;self) -&gt; Box&lt;T&gt; { box get_it(&amp;**self) }
}
#}</code></pre></pre>
<p>What happens when we invoke <code>get_it(&amp;box 1_u16)</code>, for example? In this
case, the <code>Self</code> type is <code>Box&lt;u16&gt;</code> – that unifies with both impls,
because the first applies to all types, and the second to all
boxes. In the olden days we'd have called this ambiguous. But what we
do now is do a second <em>winnowing</em> pass that considers where clauses
and attempts to remove candidates – in this case, the first impl only
applies if <code>Box&lt;u16&gt; : Copy</code>, which doesn't hold. After winnowing,
then, we are left with just one candidate, so we can proceed. There is
a test of this in <code>src/test/run-pass/traits-conditional-dispatch.rs</code>.</p>
<a class="header" href="print.html#matching" id="matching"><h4>Matching</h4></a>
<p>The subroutines that decide whether a particular impl/where-clause/etc
applies to a particular obligation. At the moment, this amounts to
unifying the self types, but in the future we may also recursively
consider some of the nested obligations, in the case of an impl.</p>
<a class="header" href="print.html#lifetimes-and-selection" id="lifetimes-and-selection"><h4>Lifetimes and selection</h4></a>
<p>Because of how that lifetime inference works, it is not possible to
give back immediate feedback as to whether a unification or subtype
relationship between lifetimes holds or not. Therefore, lifetime
matching is <em>not</em> considered during selection. This is reflected in
the fact that subregion assignment is infallible. This may yield
lifetime constraints that will later be found to be in error (in
contrast, the non-lifetime-constraints have already been checked
during selection and can never cause an error, though naturally they
may lead to other errors downstream).</p>
<a class="header" href="print.html#where-clauses" id="where-clauses"><h4>Where clauses</h4></a>
<p>Besides an impl, the other major way to resolve an obligation is via a
where clause. The selection process is always given a <em>parameter
environment</em> which contains a list of where clauses, which are
basically obligations that can assume are satisfiable. We will iterate
over that list and check whether our current obligation can be found
in that list, and if so it is considered satisfied. More precisely, we
want to check whether there is a where-clause obligation that is for
the same trait (or some subtrait) and for which the self types match,
using the definition of <em>matching</em> given above.</p>
<p>Consider this simple example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait A1 { /*...*/ }
trait A2 : A1 { /*...*/ }

trait B { /*...*/ }

fn foo&lt;X:A2+B&gt; { /*...*/ }
#}</code></pre></pre>
<p>Clearly we can use methods offered by <code>A1</code>, <code>A2</code>, or <code>B</code> within the
body of <code>foo</code>. In each case, that will incur an obligation like <code>X : A1</code> or <code>X : A2</code>. The parameter environment will contain two
where-clauses, <code>X : A2</code> and <code>X : B</code>. For each obligation, then, we
search this list of where-clauses.  To resolve an obligation <code>X:A1</code>,
we would note that <code>X:A2</code> implies that <code>X:A1</code>.</p>
<a class="header" href="print.html#confirmation" id="confirmation"><h3>Confirmation</h3></a>
<p>Confirmation unifies the output type parameters of the trait with the
values found in the obligation, possibly yielding a type error.  If we
return to our example of the <code>Convert</code> trait from the previous
section, confirmation is where an error would be reported, because the
impl specified that <code>T</code> would be <code>usize</code>, but the obligation reported
<code>char</code>. Hence the result of selection would be an error.</p>
<a class="header" href="print.html#selection-during-translation" id="selection-during-translation"><h3>Selection during translation</h3></a>
<p>During type checking, we do not store the results of trait selection.
We simply wish to verify that trait selection will succeed. Then
later, at trans time, when we have all concrete types available, we
can repeat the trait selection.  In this case, we do not consider any
where-clauses to be in scope. We know that therefore each resolution
will resolve to a particular impl.</p>
<p>One interesting twist has to do with nested obligations. In general, in trans,
we only need to do a &quot;shallow&quot; selection for an obligation. That is, we wish to
identify which impl applies, but we do not (yet) need to decide how to select
any nested obligations. Nonetheless, we <em>do</em> currently do a complete resolution,
and that is because it can sometimes inform the results of type inference. That is,
we do not have the full substitutions in terms of the type variables of the impl available
to us, so we must run trait selection to figure everything out.</p>
<p>Here is an example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo { /*...*/ }
impl&lt;U,T:Bar&lt;U&gt;&gt; Foo for Vec&lt;T&gt; { /*...*/ }

impl Bar&lt;usize&gt; for isize { /*...*/ }
#}</code></pre></pre>
<p>After one shallow round of selection for an obligation like <code>Vec&lt;isize&gt; : Foo</code>, we would know which impl we want, and we would know that
<code>T=isize</code>, but we do not know the type of <code>U</code>.  We must select the
nested obligation <code>isize : Bar&lt;U&gt;</code> to find out that <code>U=usize</code>.</p>
<p>It would be good to only do <em>just as much</em> nested resolution as
necessary. Currently, though, we just do a full resolution.</p>
<a class="header" href="print.html#higher-ranked-trait-bounds" id="higher-ranked-trait-bounds"><h1>Higher-ranked trait bounds</h1></a>
<p>One of the more subtle concepts at work are <em>higher-ranked trait
bounds</em>. An example of such a bound is <code>for&lt;'a&gt; MyTrait&lt;&amp;'a isize&gt;</code>.
Let's walk through how selection on higher-ranked trait references
works.</p>
<a class="header" href="print.html#basic-matching-and-skolemization-leaks" id="basic-matching-and-skolemization-leaks"><h2>Basic matching and skolemization leaks</h2></a>
<p>Let's walk through the test <code>compile-fail/hrtb-just-for-static.rs</code> to see
how it works. The test starts with the trait <code>Foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}
#}</code></pre></pre>
<p>Let's say we have a function <code>want_hrtb</code> that wants a type which
implements <code>Foo&lt;&amp;'a isize&gt;</code> for any <code>'a</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn want_hrtb&lt;T&gt;() where T : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt; { ... }
#}</code></pre></pre>
<p>Now we have a struct <code>AnyInt</code> that implements <code>Foo&lt;&amp;'a isize&gt;</code> for any
<code>'a</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct AnyInt;
impl&lt;'a&gt; Foo&lt;&amp;'a isize&gt; for AnyInt { }
#}</code></pre></pre>
<p>And the question is, does <code>AnyInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code>? We want the
answer to be yes. The algorithm for figuring it out is closely related
to the subtyping for higher-ranked types (which is described in
<code>middle::infer::higher_ranked::doc</code>, but also in a <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/">paper by SPJ</a> that
I recommend you read).</p>
<ol>
<li>Skolemize the obligation.</li>
<li>Match the impl against the skolemized obligation.</li>
<li>Check for skolemization leaks.</li>
</ol>
<p>So let's work through our example. The first thing we would do is to
skolemize the obligation, yielding <code>AnyInt : Foo&lt;&amp;'0 isize&gt;</code> (here <code>'0</code>
represents skolemized region #0). Note that now have no quantifiers;
in terms of the compiler type, this changes from a <code>ty::PolyTraitRef</code>
to a <code>TraitRef</code>. We would then create the <code>TraitRef</code> from the impl,
using fresh variables for it's bound regions (and thus getting
<code>Foo&lt;&amp;'$a isize&gt;</code>, where <code>'$a</code> is the inference variable for <code>'a</code>). Next
we relate the two trait refs, yielding a graph with the constraint
that <code>'0 == '$a</code>. Finally, we check for skolemization &quot;leaks&quot; – a
leak is basically any attempt to relate a skolemized region to another
skolemized region, or to any region that pre-existed the impl match.
The leak check is done by searching from the skolemized region to find
the set of regions that it is related to in any way. This is called
the &quot;taint&quot; set. To pass the check, that set must consist <em>solely</em> of
itself and region variables from the impl. If the taint set includes
any other region, then the match is a failure. In this case, the taint
set for <code>'0</code> is <code>{'0, '$a}</code>, and hence the check will succeed.</p>
<p>Let's consider a failure case. Imagine we also have a struct</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct StaticInt;
impl Foo&lt;&amp;'static isize&gt; for StaticInt;
#}</code></pre></pre>
<p>We want the obligation <code>StaticInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> to be
considered unsatisfied. The check begins just as before. <code>'a</code> is
skolemized to <code>'0</code> and the impl trait reference is instantiated to
<code>Foo&lt;&amp;'static isize&gt;</code>. When we relate those two, we get a constraint
like <code>'static == '0</code>. This means that the taint set for <code>'0</code> is <code>{'0, 'static}</code>, which fails the leak check.</p>
<a class="header" href="print.html#higher-ranked-trait-obligations" id="higher-ranked-trait-obligations"><h2>Higher-ranked trait obligations</h2></a>
<p>Once the basic matching is done, we get to another interesting topic:
how to deal with impl obligations. I'll work through a simple example
here. Imagine we have the traits <code>Foo</code> and <code>Bar</code> and an associated impl:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}

trait Bar&lt;X&gt; {
    fn bar(&amp;self, x: X) { }
}

impl&lt;X,F&gt; Foo&lt;X&gt; for F
    where F : Bar&lt;X&gt;
{
}
#}</code></pre></pre>
<p>Now let's say we have a obligation <code>for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> and we match
this impl. What obligation is generated as a result? We want to get
<code>for&lt;'a&gt; Bar&lt;&amp;'a isize&gt;</code>, but how does that happen?</p>
<p>After the matching, we are in a position where we have a skolemized
substitution like <code>X =&gt; &amp;'0 isize</code>. If we apply this substitution to the
impl obligations, we get <code>F : Bar&lt;&amp;'0 isize&gt;</code>. Obviously this is not
directly usable because the skolemized region <code>'0</code> cannot leak out of
our computation.</p>
<p>What we do is to create an inverse mapping from the taint set of <code>'0</code>
back to the original bound region (<code>'a</code>, here) that <code>'0</code> resulted
from. (This is done in <code>higher_ranked::plug_leaks</code>). We know that the
leak check passed, so this taint set consists solely of the skolemized
region itself plus various intermediate region variables. We then walk
the trait-reference and convert every region in that taint set back to
a late-bound region, so in this case we'd wind up with <code>for&lt;'a&gt; F : Bar&lt;&amp;'a isize&gt;</code>.</p>
<a class="header" href="print.html#caching-and-subtle-considerations-therewith" id="caching-and-subtle-considerations-therewith"><h1>Caching and subtle considerations therewith</h1></a>
<p>In general we attempt to cache the results of trait selection.  This
is a somewhat complex process. Part of the reason for this is that we
want to be able to cache results even when all the types in the trait
reference are not fully known. In that case, it may happen that the
trait selection process is also influencing type variables, so we have
to be able to not only cache the <em>result</em> of the selection process,
but <em>replay</em> its effects on the type variables.</p>
<a class="header" href="print.html#an-example" id="an-example"><h2>An example</h2></a>
<p>The high-level idea of how the cache works is that we first replace
all unbound inference variables with skolemized versions. Therefore,
if we had a trait reference <code>usize : Foo&lt;$1&gt;</code>, where <code>$n</code> is an unbound
inference variable, we might replace it with <code>usize : Foo&lt;%0&gt;</code>, where
<code>%n</code> is a skolemized type. We would then look this up in the cache.
If we found a hit, the hit would tell us the immediate next step to
take in the selection process: i.e. apply impl #22, or apply where
clause <code>X : Foo&lt;Y&gt;</code>. Let's say in this case there is no hit.
Therefore, we search through impls and where clauses and so forth, and
we come to the conclusion that the only possible impl is this one,
with def-id 22:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Foo&lt;isize&gt; for usize { ... } // Impl #22
#}</code></pre></pre>
<p>We would then record in the cache <code>usize : Foo&lt;%0&gt; ==&gt; ImplCandidate(22)</code>. Next we would confirm <code>ImplCandidate(22)</code>, which
would (as a side-effect) unify <code>$1</code> with <code>isize</code>.</p>
<p>Now, at some later time, we might come along and see a <code>usize : Foo&lt;$3&gt;</code>.  When skolemized, this would yield <code>usize : Foo&lt;%0&gt;</code>, just as
before, and hence the cache lookup would succeed, yielding
<code>ImplCandidate(22)</code>. We would confirm <code>ImplCandidate(22)</code> which would
(as a side-effect) unify <code>$3</code> with <code>isize</code>.</p>
<a class="header" href="print.html#where-clauses-and-the-local-vs-global-cache" id="where-clauses-and-the-local-vs-global-cache"><h2>Where clauses and the local vs global cache</h2></a>
<p>One subtle interaction is that the results of trait lookup will vary
depending on what where clauses are in scope. Therefore, we actually
have <em>two</em> caches, a local and a global cache. The local cache is
attached to the <code>ParamEnv</code> and the global cache attached to the
<code>tcx</code>. We use the local cache whenever the result might depend on the
where clauses that are in scope. The determination of which cache to
use is done by the method <code>pick_candidate_cache</code> in <code>select.rs</code>. At
the moment, we use a very simple, conservative rule: if there are any
where-clauses in scope, then we use the local cache.  We used to try
and draw finer-grained distinctions, but that led to a serious of
annoying and weird bugs like #22019 and #18290. This simple rule seems
to be pretty clearly safe and also still retains a very high hit rate
(~95% when compiling rustc).</p>
<a class="header" href="print.html#specialization" id="specialization"><h1>Specialization</h1></a>
<p>Defined in the <code>specialize</code> module.</p>
<p>The basic strategy is to build up a <em>specialization graph</em> during
coherence checking. Insertion into the graph locates the right place
to put an impl in the specialization hierarchy; if there is no right
place (due to partial overlap but no containment), you get an overlap
error. Specialization is consulted when selecting an impl (of course),
and the graph is consulted when propagating defaults down the
specialization hierarchy.</p>
<p>You might expect that the specialization graph would be used during
selection – i.e. when actually performing specialization. This is
not done for two reasons:</p>
<ul>
<li>
<p>It's merely an optimization: given a set of candidates that apply,
we can determine the most specialized one by comparing them directly
for specialization, rather than consulting the graph. Given that we
also cache the results of selection, the benefit of this
optimization is questionable.</p>
</li>
<li>
<p>To build the specialization graph in the first place, we need to use
selection (because we need to determine whether one impl specializes
another). Dealing with this reentrancy would require some additional
mode switch for selection. Given that there seems to be no strong
reason to use the graph anyway, we stick with a simpler approach in
selection, and use the graph only for propagating default
implementations.</p>
</li>
</ul>
<p>Trait impl selection can succeed even when multiple impls can apply,
as long as they are part of the same specialization family. In that
case, it returns a <em>single</em> impl on success – this is the most
specialized impl <em>known</em> to apply. However, if there are any inference
variables in play, the returned impl may not be the actual impl we
will use at trans time. Thus, we take special care to avoid projecting
associated types unless either (1) the associated type does not use
<code>default</code> and thus cannot be overridden or (2) all input types are
known concretely.</p>
<a class="header" href="print.html#type-checking" id="type-checking"><h1>Type checking</h1></a>
<a class="header" href="print.html#the-mir-mid-level-ir" id="the-mir-mid-level-ir"><h1>The MIR (Mid-level IR)</h1></a>
<p>MIR is Rust's <em>Mid-level Intermediate Representation</em>. It is constructed from
HIR (described in an earlier chapter).</p>
<p>MIR is defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc/mir"><code>src/librustc/mir/</code></a> module, but much of the code
that manipulates it is found in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir"><code>src/librustc_mir</code></a>.</p>
<p><em>NOTE: copy/pasted from README... needs editing</em></p>
<a class="header" href="print.html#mir-definition-and-pass-system" id="mir-definition-and-pass-system"><h1>MIR definition and pass system</h1></a>
<p>This file contains the definition of the MIR datatypes along with the
various types for the &quot;MIR Pass&quot; system, which lets you easily
register and define new MIR transformations and analyses.</p>
<p>Most of the code that operates on MIR can be found in the
<code>librustc_mir</code> crate or other crates. The code found here in
<code>librustc</code> is just the datatype definitions, along with the functions
which operate on MIR to be placed everywhere else.</p>
<a class="header" href="print.html#mir-data-types-and-visitor" id="mir-data-types-and-visitor"><h2>MIR Data Types and visitor</h2></a>
<p>The main MIR data type is <code>rustc::mir::Mir</code>, defined in <code>mod.rs</code>.
There is also the MIR visitor (in <code>visit.rs</code>) which allows you to walk
the MIR and override what actions will be taken at various points (you
can visit in either shared or mutable mode; the latter allows changing
the MIR in place). Finally <code>traverse.rs</code> contains various traversal
routines for visiting the MIR CFG in <a href="https://en.wikipedia.org/wiki/Tree_traversal">different standard orders</a>
(e.g. pre-order, reverse post-order, and so forth).</p>
<a class="header" href="print.html#mir-pass-suites-and-their-integration-into-the-query-system" id="mir-pass-suites-and-their-integration-into-the-query-system"><h2>MIR pass suites and their integration into the query system</h2></a>
<p>As a MIR <em>consumer</em>, you are expected to use one of the queries that
returns a &quot;final MIR&quot;. As of the time of this writing, there is only
one: <code>optimized_mir(def_id)</code>, but more are expected to come in the
future. For foreign def-ids, we simply read the MIR from the other
crate's metadata. But for local def-ids, the query will construct the
MIR and then iteratively optimize it by putting it through various
pipeline stages. This section describes those pipeline stages and how
you can extend them.</p>
<p>To produce the <code>optimized_mir(D)</code> for a given def-id <code>D</code>, the MIR
passes through several suites of optimizations, each represented by a
query. Each suite consists of multiple optimizations and
transformations. These suites represent useful intermediate points
where we want to access the MIR for type checking or other purposes:</p>
<ul>
<li><code>mir_build(D)</code> – not a query, but this constructs the initial MIR</li>
<li><code>mir_const(D)</code> – applies some simple transformations to make MIR ready for constant evaluation;</li>
<li><code>mir_validated(D)</code> – applies some more transformations, making MIR ready for borrow checking;</li>
<li><code>optimized_mir(D)</code> – the final state, after all optimizations have been performed.</li>
</ul>
<a class="header" href="print.html#stealing" id="stealing"><h3>Stealing</h3></a>
<p>The intermediate queries <code>mir_const()</code> and <code>mir_validated()</code> yield up
a <code>&amp;'tcx Steal&lt;Mir&lt;'tcx&gt;&gt;</code>, allocated using
<code>tcx.alloc_steal_mir()</code>. This indicates that the result may be
<strong>stolen</strong> by the next suite of optimizations – this is an
optimization to avoid cloning the MIR. Attempting to use a stolen
result will cause a panic in the compiler. Therefore, it is important
that you do not read directly from these intermediate queries except as
part of the MIR processing pipeline.</p>
<p>Because of this stealing mechanism, some care must also be taken to
ensure that, before the MIR at a particular phase in the processing
pipeline is stolen, anyone who may want to read from it has already
done so. Concretely, this means that if you have some query <code>foo(D)</code>
that wants to access the result of <code>mir_const(D)</code> or
<code>mir_validated(D)</code>, you need to have the successor pass &quot;force&quot;
<code>foo(D)</code> using <code>ty::queries::foo::force(...)</code>. This will force a query
to execute even though you don't directly require its result.</p>
<p>As an example, consider MIR const qualification. It wants to read the
result produced by the <code>mir_const()</code> suite. However, that result will
be <strong>stolen</strong> by the <code>mir_validated()</code> suite. If nothing was done,
then <code>mir_const_qualif(D)</code> would succeed if it came before
<code>mir_validated(D)</code>, but fail otherwise. Therefore, <code>mir_validated(D)</code>
will <strong>force</strong> <code>mir_const_qualif</code> before it actually steals, thus
ensuring that the reads have already happened:</p>
<pre><code>mir_const(D) --read-by--&gt; mir_const_qualif(D)
     |                       ^
  stolen-by                  |
     |                    (forces)
     v                       |
mir_validated(D) ------------+
</code></pre>
<a class="header" href="print.html#implementing-and-registering-a-pass" id="implementing-and-registering-a-pass"><h3>Implementing and registering a pass</h3></a>
<p>To create a new MIR pass, you simply implement the <code>MirPass</code> trait for
some fresh singleton type <code>Foo</code>. Once you have implemented a trait for
your type <code>Foo</code>, you then have to insert <code>Foo</code> into one of the suites;
this is done in <code>librustc_driver/driver.rs</code> by invoking <code>push_pass(S, Foo)</code> with the appropriate suite substituted for <code>S</code>.</p>
<a class="header" href="print.html#mir-construction" id="mir-construction"><h1>MIR construction</h1></a>
<a class="header" href="print.html#mir-borrowck" id="mir-borrowck"><h1>MIR borrowck</h1></a>
<a class="header" href="print.html#mir-optimizations" id="mir-optimizations"><h1>MIR optimizations</h1></a>
<a class="header" href="print.html#generating-llvm-ir" id="generating-llvm-ir"><h1>Generating LLVM IR</h1></a>
<a class="header" href="print.html#glossary" id="glossary"><h2>Glossary</h2></a>
<p>The compiler uses a number of...idiosyncratic abbreviations and things. This glossary attempts to list them and give you a few pointers for understanding them better.</p>
<table><thead><tr><th>Term                    </th><th> Meaning</th></tr></thead><tbody>
<tr><td>AST                     </td><td>  the abstract syntax tree produced by the syntax crate; reflects user syntax very closely.</td></tr>
<tr><td>codegen unit            </td><td>  when we produce LLVM IR, we group the Rust code into a number of codegen units. Each of these units is processed by LLVM independently from one another, enabling parallelism. They are also the unit of incremental re-use.</td></tr>
<tr><td>cx                      </td><td>  we tend to use &quot;cx&quot; as an abbrevation for context. See also <code>tcx</code>, <code>infcx</code>, etc.</td></tr>
<tr><td>DefId                   </td><td>  an index identifying a definition (see <code>librustc/hir/def_id.rs</code>). Uniquely identifies a <code>DefPath</code>.</td></tr>
<tr><td>HIR                     </td><td>  the High-level IR, created by lowering and desugaring the AST (<a href="hir.html">see more</a>)</td></tr>
<tr><td>HirId                   </td><td>  identifies a particular node in the HIR by combining a def-id with an &quot;intra-definition offset&quot;.</td></tr>
<tr><td>'gcx                    </td><td>  the lifetime of the global arena (<a href="ty.html">see more</a>)</td></tr>
<tr><td>generics                </td><td>  the set of generic type parameters defined on a type or item</td></tr>
<tr><td>ICE                     </td><td>  internal compiler error. When the compiler crashes.</td></tr>
<tr><td>ICH                     </td><td>  incremental compilation hash. ICHs are used as fingerprints for things such as HIR and crate metadata, to check if changes have been made. This is useful in incremental compilation to see if part of a crate has changed and should be recompiled.</td></tr>
<tr><td>infcx                   </td><td>  the inference context (see <code>librustc/infer</code>)</td></tr>
<tr><td>MIR                     </td><td>  the Mid-level IR that is created after type-checking for use by borrowck and trans (<a href="./mir.html">see more</a>)</td></tr>
<tr><td>obligation              </td><td>  something that must be proven by the trait system (<a href="trait-resolution.html">see more</a>)</td></tr>
<tr><td>local crate             </td><td>  the crate currently being compiled.</td></tr>
<tr><td>node-id or NodeId       </td><td>  an index identifying a particular node in the AST or HIR; gradually being phased out and replaced with <code>HirId</code>.</td></tr>
<tr><td>query                   </td><td>  perhaps some sub-computation during compilation (<a href="query.html">see more</a>)</td></tr>
<tr><td>provider                </td><td>  the function that executes a query (<a href="query.html">see more</a>)</td></tr>
<tr><td>sess                    </td><td>  the compiler session, which stores global data used throughout compilation</td></tr>
<tr><td>side tables             </td><td>  because the AST and HIR are immutable once created, we often carry extra information about them in the form of hashtables, indexed by the id of a particular node.</td></tr>
<tr><td>span                    </td><td>  a location in the user's source code, used for error reporting primarily. These are like a file-name/line-number/column tuple on steroids: they carry a start/end point, and also track macro expansions and compiler desugaring. All while being packed into a few bytes (really, it's an index into a table). See the Span datatype for more.</td></tr>
<tr><td>substs                  </td><td>  the substitutions for a given generic type or item (e.g. the <code>i32</code>, <code>u32</code> in <code>HashMap&lt;i32, u32&gt;</code>)</td></tr>
<tr><td>tcx                     </td><td>  the &quot;typing context&quot;, main data structure of the compiler (<a href="ty.html">see more</a>)</td></tr>
<tr><td>'tcx                    </td><td>  the lifetime of the currently active inference context (<a href="ty.html">see more</a>)</td></tr>
<tr><td>trans                   </td><td>  the code to translate MIR into LLVM IR.</td></tr>
<tr><td>trait reference         </td><td>  a trait and values for its type parameters (<a href="ty.html">see more</a>).</td></tr>
<tr><td>ty                      </td><td>  the internal representation of a type (<a href="ty.html">see more</a>).</td></tr>
</tbody></table>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
